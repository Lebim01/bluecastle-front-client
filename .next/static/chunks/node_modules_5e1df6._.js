(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_5e1df6._.js", {

"[project]/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/**
 * Custom positioning reference element.
 * @see https://floating-ui.com/docs/virtual-elements
 */ __turbopack_esm__({
    "alignments": (()=>alignments),
    "clamp": (()=>clamp),
    "createCoords": (()=>createCoords),
    "evaluate": (()=>evaluate),
    "expandPaddingObject": (()=>expandPaddingObject),
    "floor": (()=>floor),
    "getAlignment": (()=>getAlignment),
    "getAlignmentAxis": (()=>getAlignmentAxis),
    "getAlignmentSides": (()=>getAlignmentSides),
    "getAxisLength": (()=>getAxisLength),
    "getExpandedPlacements": (()=>getExpandedPlacements),
    "getOppositeAlignmentPlacement": (()=>getOppositeAlignmentPlacement),
    "getOppositeAxis": (()=>getOppositeAxis),
    "getOppositeAxisPlacements": (()=>getOppositeAxisPlacements),
    "getOppositePlacement": (()=>getOppositePlacement),
    "getPaddingObject": (()=>getPaddingObject),
    "getSide": (()=>getSide),
    "getSideAxis": (()=>getSideAxis),
    "max": (()=>max),
    "min": (()=>min),
    "placements": (()=>placements),
    "rectToClientRect": (()=>rectToClientRect),
    "round": (()=>round),
    "sides": (()=>sides)
});
const sides = [
    'top',
    'right',
    'bottom',
    'left'
];
const alignments = [
    'start',
    'end'
];
const placements = /*#__PURE__*/ sides.reduce((acc, side)=>acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
const min = Math.min;
const max = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = (v)=>({
        x: v,
        y: v
    });
const oppositeSideMap = {
    left: 'right',
    right: 'left',
    bottom: 'top',
    top: 'bottom'
};
const oppositeAlignmentMap = {
    start: 'end',
    end: 'start'
};
function clamp(start, value, end) {
    return max(start, min(value, end));
}
function evaluate(value, param) {
    return typeof value === 'function' ? value(param) : value;
}
function getSide(placement) {
    return placement.split('-')[0];
}
function getAlignment(placement) {
    return placement.split('-')[1];
}
function getOppositeAxis(axis) {
    return axis === 'x' ? 'y' : 'x';
}
function getAxisLength(axis) {
    return axis === 'y' ? 'height' : 'width';
}
function getSideAxis(placement) {
    return [
        'top',
        'bottom'
    ].includes(getSide(placement)) ? 'y' : 'x';
}
function getAlignmentAxis(placement) {
    return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
    if (rtl === void 0) {
        rtl = false;
    }
    const alignment = getAlignment(placement);
    const alignmentAxis = getAlignmentAxis(placement);
    const length = getAxisLength(alignmentAxis);
    let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';
    if (rects.reference[length] > rects.floating[length]) {
        mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
    }
    return [
        mainAlignmentSide,
        getOppositePlacement(mainAlignmentSide)
    ];
}
function getExpandedPlacements(placement) {
    const oppositePlacement = getOppositePlacement(placement);
    return [
        getOppositeAlignmentPlacement(placement),
        oppositePlacement,
        getOppositeAlignmentPlacement(oppositePlacement)
    ];
}
function getOppositeAlignmentPlacement(placement) {
    return placement.replace(/start|end/g, (alignment)=>oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
    const lr = [
        'left',
        'right'
    ];
    const rl = [
        'right',
        'left'
    ];
    const tb = [
        'top',
        'bottom'
    ];
    const bt = [
        'bottom',
        'top'
    ];
    switch(side){
        case 'top':
        case 'bottom':
            if (rtl) return isStart ? rl : lr;
            return isStart ? lr : rl;
        case 'left':
        case 'right':
            return isStart ? tb : bt;
        default:
            return [];
    }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
    const alignment = getAlignment(placement);
    let list = getSideList(getSide(placement), direction === 'start', rtl);
    if (alignment) {
        list = list.map((side)=>side + "-" + alignment);
        if (flipAlignment) {
            list = list.concat(list.map(getOppositeAlignmentPlacement));
        }
    }
    return list;
}
function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, (side)=>oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
    return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        ...padding
    };
}
function getPaddingObject(padding) {
    return typeof padding !== 'number' ? expandPaddingObject(padding) : {
        top: padding,
        right: padding,
        bottom: padding,
        left: padding
    };
}
function rectToClientRect(rect) {
    const { x, y, width, height } = rect;
    return {
        width,
        height,
        top: y,
        left: x,
        right: x + width,
        bottom: y + height,
        x,
        y
    };
}
;
}}),
"[project]/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "getComputedStyle": (()=>getComputedStyle),
    "getContainingBlock": (()=>getContainingBlock),
    "getDocumentElement": (()=>getDocumentElement),
    "getFrameElement": (()=>getFrameElement),
    "getNearestOverflowAncestor": (()=>getNearestOverflowAncestor),
    "getNodeName": (()=>getNodeName),
    "getNodeScroll": (()=>getNodeScroll),
    "getOverflowAncestors": (()=>getOverflowAncestors),
    "getParentNode": (()=>getParentNode),
    "getWindow": (()=>getWindow),
    "isContainingBlock": (()=>isContainingBlock),
    "isElement": (()=>isElement),
    "isHTMLElement": (()=>isHTMLElement),
    "isLastTraversableNode": (()=>isLastTraversableNode),
    "isNode": (()=>isNode),
    "isOverflowElement": (()=>isOverflowElement),
    "isShadowRoot": (()=>isShadowRoot),
    "isTableElement": (()=>isTableElement),
    "isTopLayer": (()=>isTopLayer),
    "isWebKit": (()=>isWebKit)
});
function hasWindow() {
    return typeof window !== 'undefined';
}
function getNodeName(node) {
    if (isNode(node)) {
        return (node.nodeName || '').toLowerCase();
    }
    // Mocked nodes in testing environments may not be instances of Node. By
    // returning `#document` an infinite loop won't occur.
    // https://github.com/floating-ui/floating-ui/issues/2317
    return '#document';
}
function getWindow(node) {
    var _node$ownerDocument;
    return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
    var _ref;
    return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
    if (!hasWindow()) {
        return false;
    }
    return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
    if (!hasWindow()) {
        return false;
    }
    return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
    if (!hasWindow()) {
        return false;
    }
    return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
    if (!hasWindow() || typeof ShadowRoot === 'undefined') {
        return false;
    }
    return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
    const { overflow, overflowX, overflowY, display } = getComputedStyle(element);
    return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && ![
        'inline',
        'contents'
    ].includes(display);
}
function isTableElement(element) {
    return [
        'table',
        'td',
        'th'
    ].includes(getNodeName(element));
}
function isTopLayer(element) {
    return [
        ':popover-open',
        ':modal'
    ].some((selector)=>{
        try {
            return element.matches(selector);
        } catch (e) {
            return false;
        }
    });
}
function isContainingBlock(elementOrCss) {
    const webkit = isWebKit();
    const css = isElement(elementOrCss) ? getComputedStyle(elementOrCss) : elementOrCss;
    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
    // https://drafts.csswg.org/css-transforms-2/#individual-transforms
    return [
        'transform',
        'translate',
        'scale',
        'rotate',
        'perspective'
    ].some((value)=>css[value] ? css[value] !== 'none' : false) || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || [
        'transform',
        'translate',
        'scale',
        'rotate',
        'perspective',
        'filter'
    ].some((value)=>(css.willChange || '').includes(value)) || [
        'paint',
        'layout',
        'strict',
        'content'
    ].some((value)=>(css.contain || '').includes(value));
}
function getContainingBlock(element) {
    let currentNode = getParentNode(element);
    while(isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)){
        if (isContainingBlock(currentNode)) {
            return currentNode;
        } else if (isTopLayer(currentNode)) {
            return null;
        }
        currentNode = getParentNode(currentNode);
    }
    return null;
}
function isWebKit() {
    if (typeof CSS === 'undefined' || !CSS.supports) return false;
    return CSS.supports('-webkit-backdrop-filter', 'none');
}
function isLastTraversableNode(node) {
    return [
        'html',
        'body',
        '#document'
    ].includes(getNodeName(node));
}
function getComputedStyle(element) {
    return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
    if (isElement(element)) {
        return {
            scrollLeft: element.scrollLeft,
            scrollTop: element.scrollTop
        };
    }
    return {
        scrollLeft: element.scrollX,
        scrollTop: element.scrollY
    };
}
function getParentNode(node) {
    if (getNodeName(node) === 'html') {
        return node;
    }
    const result = // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node);
    return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
    const parentNode = getParentNode(node);
    if (isLastTraversableNode(parentNode)) {
        return node.ownerDocument ? node.ownerDocument.body : node.body;
    }
    if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
        return parentNode;
    }
    return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
    var _node$ownerDocument2;
    if (list === void 0) {
        list = [];
    }
    if (traverseIframes === void 0) {
        traverseIframes = true;
    }
    const scrollableAncestor = getNearestOverflowAncestor(node);
    const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
    const win = getWindow(scrollableAncestor);
    if (isBody) {
        const frameElement = getFrameElement(win);
        return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
    }
    return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
    return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}
;
}}),
"[project]/node_modules/@floating-ui/core/dist/floating-ui.core.mjs [client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "arrow": (()=>arrow),
    "autoPlacement": (()=>autoPlacement),
    "computePosition": (()=>computePosition),
    "detectOverflow": (()=>detectOverflow),
    "flip": (()=>flip),
    "hide": (()=>hide),
    "inline": (()=>inline),
    "limitShift": (()=>limitShift),
    "offset": (()=>offset),
    "shift": (()=>shift),
    "size": (()=>size)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs [client] (ecmascript)");
;
;
function computeCoordsFromPlacement(_ref, placement, rtl) {
    let { reference, floating } = _ref;
    const sideAxis = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getSideAxis"])(placement);
    const alignmentAxis = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getAlignmentAxis"])(placement);
    const alignLength = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getAxisLength"])(alignmentAxis);
    const side = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getSide"])(placement);
    const isVertical = sideAxis === 'y';
    const commonX = reference.x + reference.width / 2 - floating.width / 2;
    const commonY = reference.y + reference.height / 2 - floating.height / 2;
    const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
    let coords;
    switch(side){
        case 'top':
            coords = {
                x: commonX,
                y: reference.y - floating.height
            };
            break;
        case 'bottom':
            coords = {
                x: commonX,
                y: reference.y + reference.height
            };
            break;
        case 'right':
            coords = {
                x: reference.x + reference.width,
                y: commonY
            };
            break;
        case 'left':
            coords = {
                x: reference.x - floating.width,
                y: commonY
            };
            break;
        default:
            coords = {
                x: reference.x,
                y: reference.y
            };
    }
    switch((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getAlignment"])(placement)){
        case 'start':
            coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
            break;
        case 'end':
            coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
            break;
    }
    return coords;
}
/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a given reference element.
 *
 * This export does not have any `platform` interface logic. You will need to
 * write one for the platform you are using Floating UI with.
 */ const computePosition = async (reference, floating, config)=>{
    const { placement = 'bottom', strategy = 'absolute', middleware = [], platform } = config;
    const validMiddleware = middleware.filter(Boolean);
    const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));
    let rects = await platform.getElementRects({
        reference,
        floating,
        strategy
    });
    let { x, y } = computeCoordsFromPlacement(rects, placement, rtl);
    let statefulPlacement = placement;
    let middlewareData = {};
    let resetCount = 0;
    for(let i = 0; i < validMiddleware.length; i++){
        const { name, fn } = validMiddleware[i];
        const { x: nextX, y: nextY, data, reset } = await fn({
            x,
            y,
            initialPlacement: placement,
            placement: statefulPlacement,
            strategy,
            middlewareData,
            rects,
            platform,
            elements: {
                reference,
                floating
            }
        });
        x = nextX != null ? nextX : x;
        y = nextY != null ? nextY : y;
        middlewareData = {
            ...middlewareData,
            [name]: {
                ...middlewareData[name],
                ...data
            }
        };
        if (reset && resetCount <= 50) {
            resetCount++;
            if (typeof reset === 'object') {
                if (reset.placement) {
                    statefulPlacement = reset.placement;
                }
                if (reset.rects) {
                    rects = reset.rects === true ? await platform.getElementRects({
                        reference,
                        floating,
                        strategy
                    }) : reset.rects;
                }
                ({ x, y } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
            }
            i = -1;
        }
    }
    return {
        x,
        y,
        placement: statefulPlacement,
        strategy,
        middlewareData
    };
};
/**
 * Resolves with an object of overflow side offsets that determine how much the
 * element is overflowing a given clipping boundary on each side.
 * - positive = overflowing the boundary by that number of pixels
 * - negative = how many pixels left before it will overflow
 * - 0 = lies flush with the boundary
 * @see https://floating-ui.com/docs/detectOverflow
 */ async function detectOverflow(state, options) {
    var _await$platform$isEle;
    if (options === void 0) {
        options = {};
    }
    const { x, y, platform, rects, elements, strategy } = state;
    const { boundary = 'clippingAncestors', rootBoundary = 'viewport', elementContext = 'floating', altBoundary = false, padding = 0 } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["evaluate"])(options, state);
    const paddingObject = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getPaddingObject"])(padding);
    const altContext = elementContext === 'floating' ? 'reference' : 'floating';
    const element = elements[altBoundary ? altContext : elementContext];
    const clippingClientRect = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["rectToClientRect"])(await platform.getClippingRect({
        element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating)),
        boundary,
        rootBoundary,
        strategy
    }));
    const rect = elementContext === 'floating' ? {
        x,
        y,
        width: rects.floating.width,
        height: rects.floating.height
    } : rects.reference;
    const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));
    const offsetScale = await (platform.isElement == null ? void 0 : platform.isElement(offsetParent)) ? await (platform.getScale == null ? void 0 : platform.getScale(offsetParent)) || {
        x: 1,
        y: 1
    } : {
        x: 1,
        y: 1
    };
    const elementClientRect = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["rectToClientRect"])(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({
        elements,
        rect,
        offsetParent,
        strategy
    }) : rect);
    return {
        top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
        bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
        left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
        right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
    };
}
/**
 * Provides data to position an inner element of the floating element so that it
 * appears centered to the reference element.
 * @see https://floating-ui.com/docs/arrow
 */ const arrow = (options)=>({
        name: 'arrow',
        options,
        async fn (state) {
            const { x, y, placement, rects, platform, elements, middlewareData } = state;
            // Since `element` is required, we don't Partial<> the type.
            const { element, padding = 0 } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["evaluate"])(options, state) || {};
            if (element == null) {
                return {};
            }
            const paddingObject = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getPaddingObject"])(padding);
            const coords = {
                x,
                y
            };
            const axis = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getAlignmentAxis"])(placement);
            const length = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getAxisLength"])(axis);
            const arrowDimensions = await platform.getDimensions(element);
            const isYAxis = axis === 'y';
            const minProp = isYAxis ? 'top' : 'left';
            const maxProp = isYAxis ? 'bottom' : 'right';
            const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';
            const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
            const startDiff = coords[axis] - rects.reference[axis];
            const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));
            let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
            // DOM platform can return `window` as the `offsetParent`.
            if (!clientSize || !await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent))) {
                clientSize = elements.floating[clientProp] || rects.floating[length];
            }
            const centerToReference = endDiff / 2 - startDiff / 2;
            // If the padding is large enough that it causes the arrow to no longer be
            // centered, modify the padding so that it is centered.
            const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
            const minPadding = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["min"])(paddingObject[minProp], largestPossiblePadding);
            const maxPadding = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["min"])(paddingObject[maxProp], largestPossiblePadding);
            // Make sure the arrow doesn't overflow the floating element if the center
            // point is outside the floating element's bounds.
            const min$1 = minPadding;
            const max = clientSize - arrowDimensions[length] - maxPadding;
            const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
            const offset = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["clamp"])(min$1, center, max);
            // If the reference is small enough that the arrow's padding causes it to
            // to point to nothing for an aligned placement, adjust the offset of the
            // floating element itself. To ensure `shift()` continues to take action,
            // a single reset is performed when this is true.
            const shouldAddOffset = !middlewareData.arrow && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getAlignment"])(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
            const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;
            return {
                [axis]: coords[axis] + alignmentOffset,
                data: {
                    [axis]: offset,
                    centerOffset: center - offset - alignmentOffset,
                    ...shouldAddOffset && {
                        alignmentOffset
                    }
                },
                reset: shouldAddOffset
            };
        }
    });
function getPlacementList(alignment, autoAlignment, allowedPlacements) {
    const allowedPlacementsSortedByAlignment = alignment ? [
        ...allowedPlacements.filter((placement)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getAlignment"])(placement) === alignment),
        ...allowedPlacements.filter((placement)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getAlignment"])(placement) !== alignment)
    ] : allowedPlacements.filter((placement)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getSide"])(placement) === placement);
    return allowedPlacementsSortedByAlignment.filter((placement)=>{
        if (alignment) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getAlignment"])(placement) === alignment || (autoAlignment ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getOppositeAlignmentPlacement"])(placement) !== placement : false);
        }
        return true;
    });
}
/**
 * Optimizes the visibility of the floating element by choosing the placement
 * that has the most space available automatically, without needing to specify a
 * preferred placement. Alternative to `flip`.
 * @see https://floating-ui.com/docs/autoPlacement
 */ const autoPlacement = function(options) {
    if (options === void 0) {
        options = {};
    }
    return {
        name: 'autoPlacement',
        options,
        async fn (state) {
            var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;
            const { rects, middlewareData, placement, platform, elements } = state;
            const { crossAxis = false, alignment, allowedPlacements = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["placements"], autoAlignment = true, ...detectOverflowOptions } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["evaluate"])(options, state);
            const placements$1 = alignment !== undefined || allowedPlacements === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["placements"] ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;
            const overflow = await detectOverflow(state, detectOverflowOptions);
            const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;
            const currentPlacement = placements$1[currentIndex];
            if (currentPlacement == null) {
                return {};
            }
            const alignmentSides = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getAlignmentSides"])(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));
            // Make `computeCoords` start from the right place.
            if (placement !== currentPlacement) {
                return {
                    reset: {
                        placement: placements$1[0]
                    }
                };
            }
            const currentOverflows = [
                overflow[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getSide"])(currentPlacement)],
                overflow[alignmentSides[0]],
                overflow[alignmentSides[1]]
            ];
            const allOverflows = [
                ...((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || [],
                {
                    placement: currentPlacement,
                    overflows: currentOverflows
                }
            ];
            const nextPlacement = placements$1[currentIndex + 1];
            // There are more placements to check.
            if (nextPlacement) {
                return {
                    data: {
                        index: currentIndex + 1,
                        overflows: allOverflows
                    },
                    reset: {
                        placement: nextPlacement
                    }
                };
            }
            const placementsSortedByMostSpace = allOverflows.map((d)=>{
                const alignment = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getAlignment"])(d.placement);
                return [
                    d.placement,
                    alignment && crossAxis ? // Check along the mainAxis and main crossAxis side.
                    d.overflows.slice(0, 2).reduce((acc, v)=>acc + v, 0) : // Check only the mainAxis.
                    d.overflows[0],
                    d.overflows
                ];
            }).sort((a, b)=>a[1] - b[1]);
            const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter((d)=>d[2].slice(0, // Aligned placements should not check their opposite crossAxis
                // side.
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getAlignment"])(d[0]) ? 2 : 3).every((v)=>v <= 0));
            const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];
            if (resetPlacement !== placement) {
                return {
                    data: {
                        index: currentIndex + 1,
                        overflows: allOverflows
                    },
                    reset: {
                        placement: resetPlacement
                    }
                };
            }
            return {};
        }
    };
};
/**
 * Optimizes the visibility of the floating element by flipping the `placement`
 * in order to keep it in view when the preferred placement(s) will overflow the
 * clipping boundary. Alternative to `autoPlacement`.
 * @see https://floating-ui.com/docs/flip
 */ const flip = function(options) {
    if (options === void 0) {
        options = {};
    }
    return {
        name: 'flip',
        options,
        async fn (state) {
            var _middlewareData$arrow, _middlewareData$flip;
            const { placement, middlewareData, rects, initialPlacement, platform, elements } = state;
            const { mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = true, fallbackPlacements: specifiedFallbackPlacements, fallbackStrategy = 'bestFit', fallbackAxisSideDirection = 'none', flipAlignment = true, ...detectOverflowOptions } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["evaluate"])(options, state);
            // If a reset by the arrow was caused due to an alignment offset being
            // added, we should skip any logic now since `flip()` has already done its
            // work.
            // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643
            if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
                return {};
            }
            const side = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getSide"])(placement);
            const initialSideAxis = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getSideAxis"])(initialPlacement);
            const isBasePlacement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getSide"])(initialPlacement) === initialPlacement;
            const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
            const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getOppositePlacement"])(initialPlacement)
            ] : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getExpandedPlacements"])(initialPlacement));
            const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== 'none';
            if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
                fallbackPlacements.push(...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getOppositeAxisPlacements"])(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
            }
            const placements = [
                initialPlacement,
                ...fallbackPlacements
            ];
            const overflow = await detectOverflow(state, detectOverflowOptions);
            const overflows = [];
            let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
            if (checkMainAxis) {
                overflows.push(overflow[side]);
            }
            if (checkCrossAxis) {
                const sides = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getAlignmentSides"])(placement, rects, rtl);
                overflows.push(overflow[sides[0]], overflow[sides[1]]);
            }
            overflowsData = [
                ...overflowsData,
                {
                    placement,
                    overflows
                }
            ];
            // One or more sides is overflowing.
            if (!overflows.every((side)=>side <= 0)) {
                var _middlewareData$flip2, _overflowsData$filter;
                const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
                const nextPlacement = placements[nextIndex];
                if (nextPlacement) {
                    // Try next placement and re-run the lifecycle.
                    return {
                        data: {
                            index: nextIndex,
                            overflows: overflowsData
                        },
                        reset: {
                            placement: nextPlacement
                        }
                    };
                }
                // First, find the candidates that fit on the mainAxis side of overflow,
                // then find the placement that fits the best on the main crossAxis side.
                let resetPlacement = (_overflowsData$filter = overflowsData.filter((d)=>d.overflows[0] <= 0).sort((a, b)=>a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
                // Otherwise fallback.
                if (!resetPlacement) {
                    switch(fallbackStrategy){
                        case 'bestFit':
                            {
                                var _overflowsData$filter2;
                                const placement = (_overflowsData$filter2 = overflowsData.filter((d)=>{
                                    if (hasFallbackAxisSideDirection) {
                                        const currentSideAxis = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getSideAxis"])(d.placement);
                                        return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                                        // reading directions favoring greater width.
                                        currentSideAxis === 'y';
                                    }
                                    return true;
                                }).map((d)=>[
                                        d.placement,
                                        d.overflows.filter((overflow)=>overflow > 0).reduce((acc, overflow)=>acc + overflow, 0)
                                    ]).sort((a, b)=>a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
                                if (placement) {
                                    resetPlacement = placement;
                                }
                                break;
                            }
                        case 'initialPlacement':
                            resetPlacement = initialPlacement;
                            break;
                    }
                }
                if (placement !== resetPlacement) {
                    return {
                        reset: {
                            placement: resetPlacement
                        }
                    };
                }
            }
            return {};
        }
    };
};
function getSideOffsets(overflow, rect) {
    return {
        top: overflow.top - rect.height,
        right: overflow.right - rect.width,
        bottom: overflow.bottom - rect.height,
        left: overflow.left - rect.width
    };
}
function isAnySideFullyClipped(overflow) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["sides"].some((side)=>overflow[side] >= 0);
}
/**
 * Provides data to hide the floating element in applicable situations, such as
 * when it is not in the same clipping context as the reference element.
 * @see https://floating-ui.com/docs/hide
 */ const hide = function(options) {
    if (options === void 0) {
        options = {};
    }
    return {
        name: 'hide',
        options,
        async fn (state) {
            const { rects } = state;
            const { strategy = 'referenceHidden', ...detectOverflowOptions } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["evaluate"])(options, state);
            switch(strategy){
                case 'referenceHidden':
                    {
                        const overflow = await detectOverflow(state, {
                            ...detectOverflowOptions,
                            elementContext: 'reference'
                        });
                        const offsets = getSideOffsets(overflow, rects.reference);
                        return {
                            data: {
                                referenceHiddenOffsets: offsets,
                                referenceHidden: isAnySideFullyClipped(offsets)
                            }
                        };
                    }
                case 'escaped':
                    {
                        const overflow = await detectOverflow(state, {
                            ...detectOverflowOptions,
                            altBoundary: true
                        });
                        const offsets = getSideOffsets(overflow, rects.floating);
                        return {
                            data: {
                                escapedOffsets: offsets,
                                escaped: isAnySideFullyClipped(offsets)
                            }
                        };
                    }
                default:
                    {
                        return {};
                    }
            }
        }
    };
};
function getBoundingRect(rects) {
    const minX = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["min"])(...rects.map((rect)=>rect.left));
    const minY = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["min"])(...rects.map((rect)=>rect.top));
    const maxX = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["max"])(...rects.map((rect)=>rect.right));
    const maxY = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["max"])(...rects.map((rect)=>rect.bottom));
    return {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY
    };
}
function getRectsByLine(rects) {
    const sortedRects = rects.slice().sort((a, b)=>a.y - b.y);
    const groups = [];
    let prevRect = null;
    for(let i = 0; i < sortedRects.length; i++){
        const rect = sortedRects[i];
        if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {
            groups.push([
                rect
            ]);
        } else {
            groups[groups.length - 1].push(rect);
        }
        prevRect = rect;
    }
    return groups.map((rect)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["rectToClientRect"])(getBoundingRect(rect)));
}
/**
 * Provides improved positioning for inline reference elements that can span
 * over multiple lines, such as hyperlinks or range selections.
 * @see https://floating-ui.com/docs/inline
 */ const inline = function(options) {
    if (options === void 0) {
        options = {};
    }
    return {
        name: 'inline',
        options,
        async fn (state) {
            const { placement, elements, rects, platform, strategy } = state;
            // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a
            // ClientRect's bounds, despite the event listener being triggered. A
            // padding of 2 seems to handle this issue.
            const { padding = 2, x, y } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["evaluate"])(options, state);
            const nativeClientRects = Array.from(await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference)) || []);
            const clientRects = getRectsByLine(nativeClientRects);
            const fallback = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["rectToClientRect"])(getBoundingRect(nativeClientRects));
            const paddingObject = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getPaddingObject"])(padding);
            function getBoundingClientRect() {
                // There are two rects and they are disjoined.
                if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {
                    // Find the first rect in which the point is fully inside.
                    return clientRects.find((rect)=>x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;
                }
                // There are 2 or more connected rects.
                if (clientRects.length >= 2) {
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getSideAxis"])(placement) === 'y') {
                        const firstRect = clientRects[0];
                        const lastRect = clientRects[clientRects.length - 1];
                        const isTop = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getSide"])(placement) === 'top';
                        const top = firstRect.top;
                        const bottom = lastRect.bottom;
                        const left = isTop ? firstRect.left : lastRect.left;
                        const right = isTop ? firstRect.right : lastRect.right;
                        const width = right - left;
                        const height = bottom - top;
                        return {
                            top,
                            bottom,
                            left,
                            right,
                            width,
                            height,
                            x: left,
                            y: top
                        };
                    }
                    const isLeftSide = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getSide"])(placement) === 'left';
                    const maxRight = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["max"])(...clientRects.map((rect)=>rect.right));
                    const minLeft = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["min"])(...clientRects.map((rect)=>rect.left));
                    const measureRects = clientRects.filter((rect)=>isLeftSide ? rect.left === minLeft : rect.right === maxRight);
                    const top = measureRects[0].top;
                    const bottom = measureRects[measureRects.length - 1].bottom;
                    const left = minLeft;
                    const right = maxRight;
                    const width = right - left;
                    const height = bottom - top;
                    return {
                        top,
                        bottom,
                        left,
                        right,
                        width,
                        height,
                        x: left,
                        y: top
                    };
                }
                return fallback;
            }
            const resetRects = await platform.getElementRects({
                reference: {
                    getBoundingClientRect
                },
                floating: elements.floating,
                strategy
            });
            if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {
                return {
                    reset: {
                        rects: resetRects
                    }
                };
            }
            return {};
        }
    };
};
// For type backwards-compatibility, the `OffsetOptions` type was also
// Derivable.
async function convertValueToCoords(state, options) {
    const { placement, platform, elements } = state;
    const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
    const side = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getSide"])(placement);
    const alignment = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getAlignment"])(placement);
    const isVertical = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getSideAxis"])(placement) === 'y';
    const mainAxisMulti = [
        'left',
        'top'
    ].includes(side) ? -1 : 1;
    const crossAxisMulti = rtl && isVertical ? -1 : 1;
    const rawValue = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["evaluate"])(options, state);
    // eslint-disable-next-line prefer-const
    let { mainAxis, crossAxis, alignmentAxis } = typeof rawValue === 'number' ? {
        mainAxis: rawValue,
        crossAxis: 0,
        alignmentAxis: null
    } : {
        mainAxis: rawValue.mainAxis || 0,
        crossAxis: rawValue.crossAxis || 0,
        alignmentAxis: rawValue.alignmentAxis
    };
    if (alignment && typeof alignmentAxis === 'number') {
        crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;
    }
    return isVertical ? {
        x: crossAxis * crossAxisMulti,
        y: mainAxis * mainAxisMulti
    } : {
        x: mainAxis * mainAxisMulti,
        y: crossAxis * crossAxisMulti
    };
}
/**
 * Modifies the placement by translating the floating element along the
 * specified axes.
 * A number (shorthand for `mainAxis` or distance), or an axes configuration
 * object may be passed.
 * @see https://floating-ui.com/docs/offset
 */ const offset = function(options) {
    if (options === void 0) {
        options = 0;
    }
    return {
        name: 'offset',
        options,
        async fn (state) {
            var _middlewareData$offse, _middlewareData$arrow;
            const { x, y, placement, middlewareData } = state;
            const diffCoords = await convertValueToCoords(state, options);
            // If the placement is the same and the arrow caused an alignment offset
            // then we don't need to change the positioning coordinates.
            if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
                return {};
            }
            return {
                x: x + diffCoords.x,
                y: y + diffCoords.y,
                data: {
                    ...diffCoords,
                    placement
                }
            };
        }
    };
};
/**
 * Optimizes the visibility of the floating element by shifting it in order to
 * keep it in view when it will overflow the clipping boundary.
 * @see https://floating-ui.com/docs/shift
 */ const shift = function(options) {
    if (options === void 0) {
        options = {};
    }
    return {
        name: 'shift',
        options,
        async fn (state) {
            const { x, y, placement } = state;
            const { mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = false, limiter = {
                fn: (_ref)=>{
                    let { x, y } = _ref;
                    return {
                        x,
                        y
                    };
                }
            }, ...detectOverflowOptions } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["evaluate"])(options, state);
            const coords = {
                x,
                y
            };
            const overflow = await detectOverflow(state, detectOverflowOptions);
            const crossAxis = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getSideAxis"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getSide"])(placement));
            const mainAxis = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getOppositeAxis"])(crossAxis);
            let mainAxisCoord = coords[mainAxis];
            let crossAxisCoord = coords[crossAxis];
            if (checkMainAxis) {
                const minSide = mainAxis === 'y' ? 'top' : 'left';
                const maxSide = mainAxis === 'y' ? 'bottom' : 'right';
                const min = mainAxisCoord + overflow[minSide];
                const max = mainAxisCoord - overflow[maxSide];
                mainAxisCoord = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["clamp"])(min, mainAxisCoord, max);
            }
            if (checkCrossAxis) {
                const minSide = crossAxis === 'y' ? 'top' : 'left';
                const maxSide = crossAxis === 'y' ? 'bottom' : 'right';
                const min = crossAxisCoord + overflow[minSide];
                const max = crossAxisCoord - overflow[maxSide];
                crossAxisCoord = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["clamp"])(min, crossAxisCoord, max);
            }
            const limitedCoords = limiter.fn({
                ...state,
                [mainAxis]: mainAxisCoord,
                [crossAxis]: crossAxisCoord
            });
            return {
                ...limitedCoords,
                data: {
                    x: limitedCoords.x - x,
                    y: limitedCoords.y - y,
                    enabled: {
                        [mainAxis]: checkMainAxis,
                        [crossAxis]: checkCrossAxis
                    }
                }
            };
        }
    };
};
/**
 * Built-in `limiter` that will stop `shift()` at a certain point.
 */ const limitShift = function(options) {
    if (options === void 0) {
        options = {};
    }
    return {
        options,
        fn (state) {
            const { x, y, placement, rects, middlewareData } = state;
            const { offset = 0, mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = true } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["evaluate"])(options, state);
            const coords = {
                x,
                y
            };
            const crossAxis = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getSideAxis"])(placement);
            const mainAxis = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getOppositeAxis"])(crossAxis);
            let mainAxisCoord = coords[mainAxis];
            let crossAxisCoord = coords[crossAxis];
            const rawOffset = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["evaluate"])(offset, state);
            const computedOffset = typeof rawOffset === 'number' ? {
                mainAxis: rawOffset,
                crossAxis: 0
            } : {
                mainAxis: 0,
                crossAxis: 0,
                ...rawOffset
            };
            if (checkMainAxis) {
                const len = mainAxis === 'y' ? 'height' : 'width';
                const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
                const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
                if (mainAxisCoord < limitMin) {
                    mainAxisCoord = limitMin;
                } else if (mainAxisCoord > limitMax) {
                    mainAxisCoord = limitMax;
                }
            }
            if (checkCrossAxis) {
                var _middlewareData$offse, _middlewareData$offse2;
                const len = mainAxis === 'y' ? 'width' : 'height';
                const isOriginSide = [
                    'top',
                    'left'
                ].includes((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getSide"])(placement));
                const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
                const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
                if (crossAxisCoord < limitMin) {
                    crossAxisCoord = limitMin;
                } else if (crossAxisCoord > limitMax) {
                    crossAxisCoord = limitMax;
                }
            }
            return {
                [mainAxis]: mainAxisCoord,
                [crossAxis]: crossAxisCoord
            };
        }
    };
};
/**
 * Provides data that allows you to change the size of the floating element 
 * for instance, prevent it from overflowing the clipping boundary or match the
 * width of the reference element.
 * @see https://floating-ui.com/docs/size
 */ const size = function(options) {
    if (options === void 0) {
        options = {};
    }
    return {
        name: 'size',
        options,
        async fn (state) {
            var _state$middlewareData, _state$middlewareData2;
            const { placement, rects, platform, elements } = state;
            const { apply = ()=>{}, ...detectOverflowOptions } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["evaluate"])(options, state);
            const overflow = await detectOverflow(state, detectOverflowOptions);
            const side = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getSide"])(placement);
            const alignment = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getAlignment"])(placement);
            const isYAxis = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getSideAxis"])(placement) === 'y';
            const { width, height } = rects.floating;
            let heightSide;
            let widthSide;
            if (side === 'top' || side === 'bottom') {
                heightSide = side;
                widthSide = alignment === (await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)) ? 'start' : 'end') ? 'left' : 'right';
            } else {
                widthSide = side;
                heightSide = alignment === 'end' ? 'top' : 'bottom';
            }
            const maximumClippingHeight = height - overflow.top - overflow.bottom;
            const maximumClippingWidth = width - overflow.left - overflow.right;
            const overflowAvailableHeight = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["min"])(height - overflow[heightSide], maximumClippingHeight);
            const overflowAvailableWidth = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["min"])(width - overflow[widthSide], maximumClippingWidth);
            const noShift = !state.middlewareData.shift;
            let availableHeight = overflowAvailableHeight;
            let availableWidth = overflowAvailableWidth;
            if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
                availableWidth = maximumClippingWidth;
            }
            if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
                availableHeight = maximumClippingHeight;
            }
            if (noShift && !alignment) {
                const xMin = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["max"])(overflow.left, 0);
                const xMax = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["max"])(overflow.right, 0);
                const yMin = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["max"])(overflow.top, 0);
                const yMax = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["max"])(overflow.bottom, 0);
                if (isYAxis) {
                    availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["max"])(overflow.left, overflow.right));
                } else {
                    availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["max"])(overflow.top, overflow.bottom));
                }
            }
            await apply({
                ...state,
                availableWidth,
                availableHeight
            });
            const nextDimensions = await platform.getDimensions(elements.floating);
            if (width !== nextDimensions.width || height !== nextDimensions.height) {
                return {
                    reset: {
                        rects: true
                    }
                };
            }
            return {};
        }
    };
};
;
}}),
"[project]/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs [client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "arrow": (()=>arrow),
    "autoPlacement": (()=>autoPlacement),
    "autoUpdate": (()=>autoUpdate),
    "computePosition": (()=>computePosition),
    "detectOverflow": (()=>detectOverflow),
    "flip": (()=>flip),
    "hide": (()=>hide),
    "inline": (()=>inline),
    "limitShift": (()=>limitShift),
    "offset": (()=>offset),
    "platform": (()=>platform),
    "shift": (()=>shift),
    "size": (()=>size)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@floating-ui/core/dist/floating-ui.core.mjs [client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs [client] (ecmascript)");
;
;
;
;
function getCssDimensions(element) {
    const css = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getComputedStyle"])(element);
    // In testing environments, the `width` and `height` properties are empty
    // strings for SVG elements, returning NaN. Fallback to `0` in this case.
    let width = parseFloat(css.width) || 0;
    let height = parseFloat(css.height) || 0;
    const hasOffset = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isHTMLElement"])(element);
    const offsetWidth = hasOffset ? element.offsetWidth : width;
    const offsetHeight = hasOffset ? element.offsetHeight : height;
    const shouldFallback = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["round"])(width) !== offsetWidth || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["round"])(height) !== offsetHeight;
    if (shouldFallback) {
        width = offsetWidth;
        height = offsetHeight;
    }
    return {
        width,
        height,
        $: shouldFallback
    };
}
function unwrapElement(element) {
    return !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isElement"])(element) ? element.contextElement : element;
}
function getScale(element) {
    const domElement = unwrapElement(element);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isHTMLElement"])(domElement)) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["createCoords"])(1);
    }
    const rect = domElement.getBoundingClientRect();
    const { width, height, $ } = getCssDimensions(domElement);
    let x = ($ ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["round"])(rect.width) : rect.width) / width;
    let y = ($ ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["round"])(rect.height) : rect.height) / height;
    // 0, NaN, or Infinity should always fallback to 1.
    if (!x || !Number.isFinite(x)) {
        x = 1;
    }
    if (!y || !Number.isFinite(y)) {
        y = 1;
    }
    return {
        x,
        y
    };
}
const noOffsets = /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["createCoords"])(0);
function getVisualOffsets(element) {
    const win = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getWindow"])(element);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isWebKit"])() || !win.visualViewport) {
        return noOffsets;
    }
    return {
        x: win.visualViewport.offsetLeft,
        y: win.visualViewport.offsetTop
    };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
    if (isFixed === void 0) {
        isFixed = false;
    }
    if (!floatingOffsetParent || isFixed && floatingOffsetParent !== (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getWindow"])(element)) {
        return false;
    }
    return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
    if (includeScale === void 0) {
        includeScale = false;
    }
    if (isFixedStrategy === void 0) {
        isFixedStrategy = false;
    }
    const clientRect = element.getBoundingClientRect();
    const domElement = unwrapElement(element);
    let scale = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["createCoords"])(1);
    if (includeScale) {
        if (offsetParent) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isElement"])(offsetParent)) {
                scale = getScale(offsetParent);
            }
        } else {
            scale = getScale(element);
        }
    }
    const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["createCoords"])(0);
    let x = (clientRect.left + visualOffsets.x) / scale.x;
    let y = (clientRect.top + visualOffsets.y) / scale.y;
    let width = clientRect.width / scale.x;
    let height = clientRect.height / scale.y;
    if (domElement) {
        const win = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getWindow"])(domElement);
        const offsetWin = offsetParent && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isElement"])(offsetParent) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getWindow"])(offsetParent) : offsetParent;
        let currentWin = win;
        let currentIFrame = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getFrameElement"])(currentWin);
        while(currentIFrame && offsetParent && offsetWin !== currentWin){
            const iframeScale = getScale(currentIFrame);
            const iframeRect = currentIFrame.getBoundingClientRect();
            const css = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getComputedStyle"])(currentIFrame);
            const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
            const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
            x *= iframeScale.x;
            y *= iframeScale.y;
            width *= iframeScale.x;
            height *= iframeScale.y;
            x += left;
            y += top;
            currentWin = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getWindow"])(currentIFrame);
            currentIFrame = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getFrameElement"])(currentWin);
        }
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["rectToClientRect"])({
        width,
        height,
        x,
        y
    });
}
// If <html> has a CSS width greater than the viewport, then this will be
// incorrect for RTL.
function getWindowScrollBarX(element, rect) {
    const leftScroll = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getNodeScroll"])(element).scrollLeft;
    if (!rect) {
        return getBoundingClientRect((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getDocumentElement"])(element)).left + leftScroll;
    }
    return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
    if (ignoreScrollbarX === void 0) {
        ignoreScrollbarX = false;
    }
    const htmlRect = documentElement.getBoundingClientRect();
    const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect));
    const y = htmlRect.top + scroll.scrollTop;
    return {
        x,
        y
    };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
    let { elements, rect, offsetParent, strategy } = _ref;
    const isFixed = strategy === 'fixed';
    const documentElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getDocumentElement"])(offsetParent);
    const topLayer = elements ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isTopLayer"])(elements.floating) : false;
    if (offsetParent === documentElement || topLayer && isFixed) {
        return rect;
    }
    let scroll = {
        scrollLeft: 0,
        scrollTop: 0
    };
    let scale = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["createCoords"])(1);
    const offsets = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["createCoords"])(0);
    const isOffsetParentAnElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isHTMLElement"])(offsetParent);
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getNodeName"])(offsetParent) !== 'body' || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isOverflowElement"])(documentElement)) {
            scroll = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getNodeScroll"])(offsetParent);
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isHTMLElement"])(offsetParent)) {
            const offsetRect = getBoundingClientRect(offsetParent);
            scale = getScale(offsetParent);
            offsets.x = offsetRect.x + offsetParent.clientLeft;
            offsets.y = offsetRect.y + offsetParent.clientTop;
        }
    }
    const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["createCoords"])(0);
    return {
        width: rect.width * scale.x,
        height: rect.height * scale.y,
        x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
        y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
    };
}
function getClientRects(element) {
    return Array.from(element.getClientRects());
}
// Gets the entire size of the scrollable document area, even extending outside
// of the `<html>` and `<body>` rect bounds if horizontally scrollable.
function getDocumentRect(element) {
    const html = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getDocumentElement"])(element);
    const scroll = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getNodeScroll"])(element);
    const body = element.ownerDocument.body;
    const width = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["max"])(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
    const height = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["max"])(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
    let x = -scroll.scrollLeft + getWindowScrollBarX(element);
    const y = -scroll.scrollTop;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getComputedStyle"])(body).direction === 'rtl') {
        x += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["max"])(html.clientWidth, body.clientWidth) - width;
    }
    return {
        width,
        height,
        x,
        y
    };
}
function getViewportRect(element, strategy) {
    const win = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getWindow"])(element);
    const html = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getDocumentElement"])(element);
    const visualViewport = win.visualViewport;
    let width = html.clientWidth;
    let height = html.clientHeight;
    let x = 0;
    let y = 0;
    if (visualViewport) {
        width = visualViewport.width;
        height = visualViewport.height;
        const visualViewportBased = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isWebKit"])();
        if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {
            x = visualViewport.offsetLeft;
            y = visualViewport.offsetTop;
        }
    }
    return {
        width,
        height,
        x,
        y
    };
}
// Returns the inner client rect, subtracting scrollbars if present.
function getInnerBoundingClientRect(element, strategy) {
    const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');
    const top = clientRect.top + element.clientTop;
    const left = clientRect.left + element.clientLeft;
    const scale = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isHTMLElement"])(element) ? getScale(element) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["createCoords"])(1);
    const width = element.clientWidth * scale.x;
    const height = element.clientHeight * scale.y;
    const x = left * scale.x;
    const y = top * scale.y;
    return {
        width,
        height,
        x,
        y
    };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
    let rect;
    if (clippingAncestor === 'viewport') {
        rect = getViewportRect(element, strategy);
    } else if (clippingAncestor === 'document') {
        rect = getDocumentRect((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getDocumentElement"])(element));
    } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isElement"])(clippingAncestor)) {
        rect = getInnerBoundingClientRect(clippingAncestor, strategy);
    } else {
        const visualOffsets = getVisualOffsets(element);
        rect = {
            x: clippingAncestor.x - visualOffsets.x,
            y: clippingAncestor.y - visualOffsets.y,
            width: clippingAncestor.width,
            height: clippingAncestor.height
        };
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["rectToClientRect"])(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
    const parentNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getParentNode"])(element);
    if (parentNode === stopNode || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isElement"])(parentNode) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isLastTraversableNode"])(parentNode)) {
        return false;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getComputedStyle"])(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);
}
// A "clipping ancestor" is an `overflow` element with the characteristic of
// clipping (or hiding) child elements. This returns all clipping ancestors
// of the given element up the tree.
function getClippingElementAncestors(element, cache) {
    const cachedResult = cache.get(element);
    if (cachedResult) {
        return cachedResult;
    }
    let result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getOverflowAncestors"])(element, [], false).filter((el)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isElement"])(el) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getNodeName"])(el) !== 'body');
    let currentContainingBlockComputedStyle = null;
    const elementIsFixed = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getComputedStyle"])(element).position === 'fixed';
    let currentNode = elementIsFixed ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getParentNode"])(element) : element;
    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
    while((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isElement"])(currentNode) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isLastTraversableNode"])(currentNode)){
        const computedStyle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getComputedStyle"])(currentNode);
        const currentNodeIsContaining = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isContainingBlock"])(currentNode);
        if (!currentNodeIsContaining && computedStyle.position === 'fixed') {
            currentContainingBlockComputedStyle = null;
        }
        const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && [
            'absolute',
            'fixed'
        ].includes(currentContainingBlockComputedStyle.position) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isOverflowElement"])(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
        if (shouldDropCurrentNode) {
            // Drop non-containing blocks.
            result = result.filter((ancestor)=>ancestor !== currentNode);
        } else {
            // Record last containing block for next iteration.
            currentContainingBlockComputedStyle = computedStyle;
        }
        currentNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getParentNode"])(currentNode);
    }
    cache.set(element, result);
    return result;
}
// Gets the maximum area that the element is visible in due to any number of
// clipping ancestors.
function getClippingRect(_ref) {
    let { element, boundary, rootBoundary, strategy } = _ref;
    const elementClippingAncestors = boundary === 'clippingAncestors' ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isTopLayer"])(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
    const clippingAncestors = [
        ...elementClippingAncestors,
        rootBoundary
    ];
    const firstClippingAncestor = clippingAncestors[0];
    const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor)=>{
        const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
        accRect.top = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["max"])(rect.top, accRect.top);
        accRect.right = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["min"])(rect.right, accRect.right);
        accRect.bottom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["min"])(rect.bottom, accRect.bottom);
        accRect.left = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["max"])(rect.left, accRect.left);
        return accRect;
    }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
    return {
        width: clippingRect.right - clippingRect.left,
        height: clippingRect.bottom - clippingRect.top,
        x: clippingRect.left,
        y: clippingRect.top
    };
}
function getDimensions(element) {
    const { width, height } = getCssDimensions(element);
    return {
        width,
        height
    };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
    const isOffsetParentAnElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isHTMLElement"])(offsetParent);
    const documentElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getDocumentElement"])(offsetParent);
    const isFixed = strategy === 'fixed';
    const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
    let scroll = {
        scrollLeft: 0,
        scrollTop: 0
    };
    const offsets = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["createCoords"])(0);
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getNodeName"])(offsetParent) !== 'body' || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isOverflowElement"])(documentElement)) {
            scroll = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getNodeScroll"])(offsetParent);
        }
        if (isOffsetParentAnElement) {
            const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
            offsets.x = offsetRect.x + offsetParent.clientLeft;
            offsets.y = offsetRect.y + offsetParent.clientTop;
        } else if (documentElement) {
            // If the <body> scrollbar appears on the left (e.g. RTL systems). Use
            // Firefox with layout.scrollbar.side = 3 in about:config to test this.
            offsets.x = getWindowScrollBarX(documentElement);
        }
    }
    const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["createCoords"])(0);
    const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
    const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
    return {
        x,
        y,
        width: rect.width,
        height: rect.height
    };
}
function isStaticPositioned(element) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getComputedStyle"])(element).position === 'static';
}
function getTrueOffsetParent(element, polyfill) {
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isHTMLElement"])(element) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getComputedStyle"])(element).position === 'fixed') {
        return null;
    }
    if (polyfill) {
        return polyfill(element);
    }
    let rawOffsetParent = element.offsetParent;
    // Firefox returns the <html> element as the offsetParent if it's non-static,
    // while Chrome and Safari return the <body> element. The <body> element must
    // be used to perform the correct calculations even if the <html> element is
    // non-static.
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getDocumentElement"])(element) === rawOffsetParent) {
        rawOffsetParent = rawOffsetParent.ownerDocument.body;
    }
    return rawOffsetParent;
}
// Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.
function getOffsetParent(element, polyfill) {
    const win = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getWindow"])(element);
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isTopLayer"])(element)) {
        return win;
    }
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isHTMLElement"])(element)) {
        let svgOffsetParent = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getParentNode"])(element);
        while(svgOffsetParent && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isLastTraversableNode"])(svgOffsetParent)){
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isElement"])(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
                return svgOffsetParent;
            }
            svgOffsetParent = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getParentNode"])(svgOffsetParent);
        }
        return win;
    }
    let offsetParent = getTrueOffsetParent(element, polyfill);
    while(offsetParent && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isTableElement"])(offsetParent) && isStaticPositioned(offsetParent)){
        offsetParent = getTrueOffsetParent(offsetParent, polyfill);
    }
    if (offsetParent && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isLastTraversableNode"])(offsetParent) && isStaticPositioned(offsetParent) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isContainingBlock"])(offsetParent)) {
        return win;
    }
    return offsetParent || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getContainingBlock"])(element) || win;
}
const getElementRects = async function(data) {
    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
    const getDimensionsFn = this.getDimensions;
    const floatingDimensions = await getDimensionsFn(data.floating);
    return {
        reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
        floating: {
            x: 0,
            y: 0,
            width: floatingDimensions.width,
            height: floatingDimensions.height
        }
    };
};
function isRTL(element) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getComputedStyle"])(element).direction === 'rtl';
}
const platform = {
    convertOffsetParentRelativeRectToViewportRelativeRect,
    getDocumentElement: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getDocumentElement"],
    getClippingRect,
    getOffsetParent,
    getElementRects,
    getClientRects,
    getDimensions,
    getScale,
    isElement: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["isElement"],
    isRTL
};
function rectsAreEqual(a, b) {
    return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
}
// https://samthor.au/2021/observing-dom/
function observeMove(element, onMove) {
    let io = null;
    let timeoutId;
    const root = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getDocumentElement"])(element);
    function cleanup() {
        var _io;
        clearTimeout(timeoutId);
        (_io = io) == null || _io.disconnect();
        io = null;
    }
    function refresh(skip, threshold) {
        if (skip === void 0) {
            skip = false;
        }
        if (threshold === void 0) {
            threshold = 1;
        }
        cleanup();
        const elementRectForRootMargin = element.getBoundingClientRect();
        const { left, top, width, height } = elementRectForRootMargin;
        if (!skip) {
            onMove();
        }
        if (!width || !height) {
            return;
        }
        const insetTop = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["floor"])(top);
        const insetRight = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["floor"])(root.clientWidth - (left + width));
        const insetBottom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["floor"])(root.clientHeight - (top + height));
        const insetLeft = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["floor"])(left);
        const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
        const options = {
            rootMargin,
            threshold: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["max"])(0, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["min"])(1, threshold)) || 1
        };
        let isFirstUpdate = true;
        function handleObserve(entries) {
            const ratio = entries[0].intersectionRatio;
            if (ratio !== threshold) {
                if (!isFirstUpdate) {
                    return refresh();
                }
                if (!ratio) {
                    // If the reference is clipped, the ratio is 0. Throttle the refresh
                    // to prevent an infinite loop of updates.
                    timeoutId = setTimeout(()=>{
                        refresh(false, 1e-7);
                    }, 1000);
                } else {
                    refresh(false, ratio);
                }
            }
            if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
                // It's possible that even though the ratio is reported as 1, the
                // element is not actually fully within the IntersectionObserver's root
                // area anymore. This can happen under performance constraints. This may
                // be a bug in the browser's IntersectionObserver implementation. To
                // work around this, we compare the element's bounding rect now with
                // what it was at the time we created the IntersectionObserver. If they
                // are not equal then the element moved, so we refresh.
                refresh();
            }
            isFirstUpdate = false;
        }
        // Older browsers don't support a `document` as the root and will throw an
        // error.
        try {
            io = new IntersectionObserver(handleObserve, {
                ...options,
                // Handle <iframe>s
                root: root.ownerDocument
            });
        } catch (e) {
            io = new IntersectionObserver(handleObserve, options);
        }
        io.observe(element);
    }
    refresh(true);
    return cleanup;
}
/**
 * Automatically updates the position of the floating element when necessary.
 * Should only be called when the floating element is mounted on the DOM or
 * visible on the screen.
 * @returns cleanup function that should be invoked when the floating element is
 * removed from the DOM or hidden from the screen.
 * @see https://floating-ui.com/docs/autoUpdate
 */ function autoUpdate(reference, floating, update, options) {
    if (options === void 0) {
        options = {};
    }
    const { ancestorScroll = true, ancestorResize = true, elementResize = typeof ResizeObserver === 'function', layoutShift = typeof IntersectionObserver === 'function', animationFrame = false } = options;
    const referenceEl = unwrapElement(reference);
    const ancestors = ancestorScroll || ancestorResize ? [
        ...referenceEl ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getOverflowAncestors"])(referenceEl) : [],
        ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["getOverflowAncestors"])(floating)
    ] : [];
    ancestors.forEach((ancestor)=>{
        ancestorScroll && ancestor.addEventListener('scroll', update, {
            passive: true
        });
        ancestorResize && ancestor.addEventListener('resize', update);
    });
    const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
    let reobserveFrame = -1;
    let resizeObserver = null;
    if (elementResize) {
        resizeObserver = new ResizeObserver((_ref)=>{
            let [firstEntry] = _ref;
            if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
                // Prevent update loops when using the `size` middleware.
                // https://github.com/floating-ui/floating-ui/issues/1740
                resizeObserver.unobserve(floating);
                cancelAnimationFrame(reobserveFrame);
                reobserveFrame = requestAnimationFrame(()=>{
                    var _resizeObserver;
                    (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
                });
            }
            update();
        });
        if (referenceEl && !animationFrame) {
            resizeObserver.observe(referenceEl);
        }
        resizeObserver.observe(floating);
    }
    let frameId;
    let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
    if (animationFrame) {
        frameLoop();
    }
    function frameLoop() {
        const nextRefRect = getBoundingClientRect(reference);
        if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
            update();
        }
        prevRefRect = nextRefRect;
        frameId = requestAnimationFrame(frameLoop);
    }
    update();
    return ()=>{
        var _resizeObserver2;
        ancestors.forEach((ancestor)=>{
            ancestorScroll && ancestor.removeEventListener('scroll', update);
            ancestorResize && ancestor.removeEventListener('resize', update);
        });
        cleanupIo == null || cleanupIo();
        (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
        resizeObserver = null;
        if (animationFrame) {
            cancelAnimationFrame(frameId);
        }
    };
}
/**
 * Resolves with an object of overflow side offsets that determine how much the
 * element is overflowing a given clipping boundary on each side.
 * - positive = overflowing the boundary by that number of pixels
 * - negative = how many pixels left before it will overflow
 * - 0 = lies flush with the boundary
 * @see https://floating-ui.com/docs/detectOverflow
 */ const detectOverflow = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["detectOverflow"];
/**
 * Modifies the placement by translating the floating element along the
 * specified axes.
 * A number (shorthand for `mainAxis` or distance), or an axes configuration
 * object may be passed.
 * @see https://floating-ui.com/docs/offset
 */ const offset = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["offset"];
/**
 * Optimizes the visibility of the floating element by choosing the placement
 * that has the most space available automatically, without needing to specify a
 * preferred placement. Alternative to `flip`.
 * @see https://floating-ui.com/docs/autoPlacement
 */ const autoPlacement = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["autoPlacement"];
/**
 * Optimizes the visibility of the floating element by shifting it in order to
 * keep it in view when it will overflow the clipping boundary.
 * @see https://floating-ui.com/docs/shift
 */ const shift = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["shift"];
/**
 * Optimizes the visibility of the floating element by flipping the `placement`
 * in order to keep it in view when the preferred placement(s) will overflow the
 * clipping boundary. Alternative to `autoPlacement`.
 * @see https://floating-ui.com/docs/flip
 */ const flip = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["flip"];
/**
 * Provides data that allows you to change the size of the floating element 
 * for instance, prevent it from overflowing the clipping boundary or match the
 * width of the reference element.
 * @see https://floating-ui.com/docs/size
 */ const size = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["size"];
/**
 * Provides data to hide the floating element in applicable situations, such as
 * when it is not in the same clipping context as the reference element.
 * @see https://floating-ui.com/docs/hide
 */ const hide = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["hide"];
/**
 * Provides data to position an inner element of the floating element so that it
 * appears centered to the reference element.
 * @see https://floating-ui.com/docs/arrow
 */ const arrow = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["arrow"];
/**
 * Provides improved positioning for inline reference elements that can span
 * over multiple lines, such as hyperlinks or range selections.
 * @see https://floating-ui.com/docs/inline
 */ const inline = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["inline"];
/**
 * Built-in `limiter` that will stop `shift()` at a certain point.
 */ const limitShift = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["limitShift"];
/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a given reference element.
 */ const computePosition = (reference, floating, options)=>{
    // This caches the expensive `getClippingElementAncestors` function so that
    // multiple lifecycle resets re-use the same result. It only lives for a
    // single call. If other functions become expensive, we can add them as well.
    const cache = new Map();
    const mergedOptions = {
        platform,
        ...options
    };
    const platformWithCache = {
        ...mergedOptions.platform,
        _c: cache
    };
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["computePosition"])(reference, floating, {
        ...mergedOptions,
        platform: platformWithCache
    });
};
;
}}),
"[project]/node_modules/react-tooltip/dist/react-tooltip.min.mjs [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/*
* React Tooltip
* {@link https://github.com/ReactTooltip/react-tooltip}
* @copyright ReactTooltip Team
* @license MIT
*/ __turbopack_esm__({
    "Tooltip": (()=>M),
    "TooltipProvider": (()=>I),
    "TooltipWrapper": (()=>B),
    "removeStyle": (()=>g)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/react/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$classnames$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/classnames/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$dom$2f$dist$2f$floating$2d$ui$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs [client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
;
;
;
const h = "react-tooltip-core-styles", w = "react-tooltip-base-styles", b = {
    core: !1,
    base: !1
};
function S({ css: e, id: t = w, type: o = "base", ref: l }) {
    var r, n;
    if (!e || "undefined" == typeof document || b[o]) return;
    if ("core" === o && "undefined" != typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"] && (null === (r = null === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"] || void 0 === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"] ? void 0 : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].env) || void 0 === r ? void 0 : r.REACT_TOOLTIP_DISABLE_CORE_STYLES)) return;
    if ("base" !== o && "undefined" != typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"] && (null === (n = null === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"] || void 0 === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"] ? void 0 : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].env) || void 0 === n ? void 0 : n.REACT_TOOLTIP_DISABLE_BASE_STYLES)) return;
    "core" === o && (t = h), l || (l = {});
    const { insertAt: i } = l;
    if (document.getElementById(t)) return;
    const c = document.head || document.getElementsByTagName("head")[0], s = document.createElement("style");
    s.id = t, s.type = "text/css", "top" === i && c.firstChild ? c.insertBefore(s, c.firstChild) : c.appendChild(s), s.styleSheet ? s.styleSheet.cssText = e : s.appendChild(document.createTextNode(e)), b[o] = !0;
}
function g({ type: e = "base", id: t = w } = {}) {
    if (!b[e]) return;
    "core" === e && (t = h);
    const o = document.getElementById(t);
    "style" === (null == o ? void 0 : o.tagName) ? null == o || o.remove() : console.warn(`[react-tooltip] Failed to remove 'style' element with id '${t}'. Call \`injectStyle()\` first`), b[e] = !1;
}
const E = async ({ elementReference: e = null, tooltipReference: t = null, tooltipArrowReference: o = null, place: l = "top", offset: r = 10, strategy: n = "absolute", middlewares: i = [
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$dom$2f$dist$2f$floating$2d$ui$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["offset"])(Number(r)),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$dom$2f$dist$2f$floating$2d$ui$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["flip"])({
        fallbackAxisSideDirection: "start"
    }),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$dom$2f$dist$2f$floating$2d$ui$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["shift"])({
        padding: 5
    })
], border: c })=>{
    if (!e) return {
        tooltipStyles: {},
        tooltipArrowStyles: {},
        place: l
    };
    if (null === t) return {
        tooltipStyles: {},
        tooltipArrowStyles: {},
        place: l
    };
    const s = i;
    return o ? (s.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$dom$2f$dist$2f$floating$2d$ui$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["arrow"])({
        element: o,
        padding: 5
    })), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$dom$2f$dist$2f$floating$2d$ui$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["computePosition"])(e, t, {
        placement: l,
        strategy: n,
        middleware: s
    }).then(({ x: e, y: t, placement: o, middlewareData: l })=>{
        var r, n;
        const i = {
            left: `${e}px`,
            top: `${t}px`,
            border: c
        }, { x: s, y: a } = null !== (r = l.arrow) && void 0 !== r ? r : {
            x: 0,
            y: 0
        }, u = null !== (n = ({
            top: "bottom",
            right: "left",
            bottom: "top",
            left: "right"
        })[o.split("-")[0]]) && void 0 !== n ? n : "bottom", d = c && {
            borderBottom: c,
            borderRight: c
        };
        let p = 0;
        if (c) {
            const e = `${c}`.match(/(\d+)px/);
            p = (null == e ? void 0 : e[1]) ? Number(e[1]) : 1;
        }
        return {
            tooltipStyles: i,
            tooltipArrowStyles: {
                left: null != s ? `${s}px` : "",
                top: null != a ? `${a}px` : "",
                right: "",
                bottom: "",
                ...d,
                [u]: `-${4 + p}px`
            },
            place: o
        };
    })) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$dom$2f$dist$2f$floating$2d$ui$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["computePosition"])(e, t, {
        placement: "bottom",
        strategy: n,
        middleware: s
    }).then(({ x: e, y: t, placement: o })=>({
            tooltipStyles: {
                left: `${e}px`,
                top: `${t}px`
            },
            tooltipArrowStyles: {},
            place: o
        }));
}, A = (e, t)=>!("CSS" in window && "supports" in window.CSS) || window.CSS.supports(e, t), _ = (e, t, o)=>{
    let l = null;
    const r = function(...r) {
        const n = ()=>{
            l = null, o || e.apply(this, r);
        };
        o && !l && (e.apply(this, r), l = setTimeout(n, t)), o || (l && clearTimeout(l), l = setTimeout(n, t));
    };
    return r.cancel = ()=>{
        l && (clearTimeout(l), l = null);
    }, r;
}, O = (e)=>null !== e && !Array.isArray(e) && "object" == typeof e, k = (e, t)=>{
    if (e === t) return !0;
    if (Array.isArray(e) && Array.isArray(t)) return e.length === t.length && e.every((e, o)=>k(e, t[o]));
    if (Array.isArray(e) !== Array.isArray(t)) return !1;
    if (!O(e) || !O(t)) return e === t;
    const o = Object.keys(e), l = Object.keys(t);
    return o.length === l.length && o.every((o)=>k(e[o], t[o]));
}, T = (e)=>{
    if (!(e instanceof HTMLElement || e instanceof SVGElement)) return !1;
    const t = getComputedStyle(e);
    return [
        "overflow",
        "overflow-x",
        "overflow-y"
    ].some((e)=>{
        const o = t.getPropertyValue(e);
        return "auto" === o || "scroll" === o;
    });
}, L = (e)=>{
    if (!e) return null;
    let t = e.parentElement;
    for(; t;){
        if (T(t)) return t;
        t = t.parentElement;
    }
    return document.scrollingElement || document.documentElement;
}, C = "undefined" != typeof window ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useLayoutEffect"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useEffect"], R = (e)=>{
    e.current && (clearTimeout(e.current), e.current = null);
}, x = "DEFAULT_TOOLTIP_ID", N = {
    anchorRefs: new Set,
    activeAnchor: {
        current: null
    },
    attach: ()=>{},
    detach: ()=>{},
    setActiveAnchor: ()=>{}
}, $ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["createContext"])({
    getTooltipData: ()=>N
}), I = ({ children: t })=>{
    const [o, l] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useState"])({
        [x]: new Set
    }), [c, s] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useState"])({
        [x]: {
            current: null
        }
    }), a = (e, ...t)=>{
        l((o)=>{
            var l;
            const r = null !== (l = o[e]) && void 0 !== l ? l : new Set;
            return t.forEach((e)=>r.add(e)), {
                ...o,
                [e]: new Set(r)
            };
        });
    }, u = (e, ...t)=>{
        l((o)=>{
            const l = o[e];
            return l ? (t.forEach((e)=>l.delete(e)), {
                ...o
            }) : o;
        });
    }, d = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useCallback"])((e = x)=>{
        var t, l;
        return {
            anchorRefs: null !== (t = o[e]) && void 0 !== t ? t : new Set,
            activeAnchor: null !== (l = c[e]) && void 0 !== l ? l : {
                current: null
            },
            attach: (...t)=>a(e, ...t),
            detach: (...t)=>u(e, ...t),
            setActiveAnchor: (t)=>((e, t)=>{
                    s((o)=>{
                        var l;
                        return (null === (l = o[e]) || void 0 === l ? void 0 : l.current) === t.current ? o : {
                            ...o,
                            [e]: t
                        };
                    });
                })(e, t)
        };
    }, [
        o,
        c,
        a,
        u
    ]), p = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useMemo"])(()=>({
            getTooltipData: d
        }), [
        d
    ]);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].createElement($.Provider, {
        value: p
    }, t);
};
function j(e = x) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useContext"])($).getTooltipData(e);
}
const B = ({ tooltipId: t, children: l, className: r, place: n, content: i, html: c, variant: a, offset: u, wrapper: d, events: p, positionStrategy: v, delayShow: m, delayHide: f })=>{
    const { attach: h, detach: w } = j(t), b = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useRef"])(null);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useEffect"])(()=>(h(b), ()=>{
            w(b);
        }), []), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].createElement("span", {
        ref: b,
        className: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$classnames$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])("react-tooltip-wrapper", r),
        "data-tooltip-place": n,
        "data-tooltip-content": i,
        "data-tooltip-html": c,
        "data-tooltip-variant": a,
        "data-tooltip-offset": u,
        "data-tooltip-wrapper": d,
        "data-tooltip-events": p,
        "data-tooltip-position-strategy": v,
        "data-tooltip-delay-show": m,
        "data-tooltip-delay-hide": f
    }, l);
};
var z = {
    tooltip: "core-styles-module_tooltip__3vRRp",
    fixed: "core-styles-module_fixed__pcSol",
    arrow: "core-styles-module_arrow__cvMwQ",
    noArrow: "core-styles-module_noArrow__xock6",
    clickable: "core-styles-module_clickable__ZuTTB",
    show: "core-styles-module_show__Nt9eE",
    closing: "core-styles-module_closing__sGnxF"
}, D = {
    tooltip: "styles-module_tooltip__mnnfp",
    arrow: "styles-module_arrow__K0L3T",
    dark: "styles-module_dark__xNqje",
    light: "styles-module_light__Z6W-X",
    success: "styles-module_success__A2AKt",
    warning: "styles-module_warning__SCK0X",
    error: "styles-module_error__JvumD",
    info: "styles-module_info__BWdHW"
};
const q = ({ forwardRef: t, id: l, className: i, classNameArrow: c, variant: u = "dark", anchorId: d, anchorSelect: p, place: v = "top", offset: m = 10, events: h = [
    "hover"
], openOnClick: w = !1, positionStrategy: b = "absolute", middlewares: S, wrapper: g, delayShow: A = 0, delayHide: O = 0, float: T = !1, hidden: x = !1, noArrow: N = !1, clickable: $ = !1, closeOnEsc: I = !1, closeOnScroll: B = !1, closeOnResize: q = !1, openEvents: H, closeEvents: M, globalCloseEvents: W, imperativeModeOnly: P, style: V, position: F, afterShow: K, afterHide: U, disableTooltip: X, content: Y, contentWrapperRef: G, isOpen: Z, defaultIsOpen: J = !1, setIsOpen: Q, activeAnchor: ee, setActiveAnchor: te, border: oe, opacity: le, arrowColor: re, role: ne = "tooltip" })=>{
    var ie;
    const ce = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useRef"])(null), se = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useRef"])(null), ae = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useRef"])(null), ue = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useRef"])(null), de = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useRef"])(null), [pe, ve] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useState"])({
        tooltipStyles: {},
        tooltipArrowStyles: {},
        place: v
    }), [me, fe] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useState"])(!1), [ye, he] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useState"])(!1), [we, be] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useState"])(null), Se = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useRef"])(!1), ge = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useRef"])(null), { anchorRefs: Ee, setActiveAnchor: Ae } = j(l), _e = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useRef"])(!1), [Oe, ke] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useState"])([]), Te = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useRef"])(!1), Le = w || h.includes("click"), Ce = Le || (null == H ? void 0 : H.click) || (null == H ? void 0 : H.dblclick) || (null == H ? void 0 : H.mousedown), Re = H ? {
        ...H
    } : {
        mouseover: !0,
        focus: !0,
        mouseenter: !1,
        click: !1,
        dblclick: !1,
        mousedown: !1
    };
    !H && Le && Object.assign(Re, {
        mouseenter: !1,
        focus: !1,
        mouseover: !1,
        click: !0
    });
    const xe = M ? {
        ...M
    } : {
        mouseout: !0,
        blur: !0,
        mouseleave: !1,
        click: !1,
        dblclick: !1,
        mouseup: !1
    };
    !M && Le && Object.assign(xe, {
        mouseleave: !1,
        blur: !1,
        mouseout: !1
    });
    const Ne = W ? {
        ...W
    } : {
        escape: I || !1,
        scroll: B || !1,
        resize: q || !1,
        clickOutsideAnchor: Ce || !1
    };
    P && (Object.assign(Re, {
        mouseenter: !1,
        focus: !1,
        click: !1,
        dblclick: !1,
        mousedown: !1
    }), Object.assign(xe, {
        mouseleave: !1,
        blur: !1,
        click: !1,
        dblclick: !1,
        mouseup: !1
    }), Object.assign(Ne, {
        escape: !1,
        scroll: !1,
        resize: !1,
        clickOutsideAnchor: !1
    })), C(()=>(Te.current = !0, ()=>{
            Te.current = !1;
        }), []);
    const $e = (e)=>{
        Te.current && (e && he(!0), setTimeout(()=>{
            Te.current && (null == Q || Q(e), void 0 === Z && fe(e));
        }, 10));
    };
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        if (void 0 === Z) return ()=>null;
        Z && he(!0);
        const e = setTimeout(()=>{
            fe(Z);
        }, 10);
        return ()=>{
            clearTimeout(e);
        };
    }, [
        Z
    ]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        if (me !== Se.current) if (R(de), Se.current = me, me) null == K || K();
        else {
            const e = ((e)=>{
                const t = e.match(/^([\d.]+)(ms|s)$/);
                if (!t) return 0;
                const [, o, l] = t;
                return Number(o) * ("ms" === l ? 1 : 1e3);
            })(getComputedStyle(document.body).getPropertyValue("--rt-transition-show-delay"));
            de.current = setTimeout(()=>{
                he(!1), be(null), null == U || U();
            }, e + 25);
        }
    }, [
        me
    ]);
    const Ie = (e)=>{
        ve((t)=>k(t, e) ? t : e);
    }, je = (e = A)=>{
        R(ae), ye ? $e(!0) : ae.current = setTimeout(()=>{
            $e(!0);
        }, e);
    }, Be = (e = O)=>{
        R(ue), ue.current = setTimeout(()=>{
            _e.current || $e(!1);
        }, e);
    }, ze = (e)=>{
        var t;
        if (!e) return;
        const o = null !== (t = e.currentTarget) && void 0 !== t ? t : e.target;
        if (!(null == o ? void 0 : o.isConnected)) return te(null), void Ae({
            current: null
        });
        A ? je() : $e(!0), te(o), Ae({
            current: o
        }), R(ue);
    }, De = ()=>{
        $ ? Be(O || 100) : O ? Be() : $e(!1), R(ae);
    }, qe = ({ x: e, y: t })=>{
        var o;
        const l = {
            getBoundingClientRect: ()=>({
                    x: e,
                    y: t,
                    width: 0,
                    height: 0,
                    top: t,
                    left: e,
                    right: e,
                    bottom: t
                })
        };
        E({
            place: null !== (o = null == we ? void 0 : we.place) && void 0 !== o ? o : v,
            offset: m,
            elementReference: l,
            tooltipReference: ce.current,
            tooltipArrowReference: se.current,
            strategy: b,
            middlewares: S,
            border: oe
        }).then((e)=>{
            Ie(e);
        });
    }, He = (e)=>{
        if (!e) return;
        const t = e, o = {
            x: t.clientX,
            y: t.clientY
        };
        qe(o), ge.current = o;
    }, Me = (e)=>{
        var t;
        if (!me) return;
        const o = e.target;
        if (!o.isConnected) return;
        if (null === (t = ce.current) || void 0 === t ? void 0 : t.contains(o)) return;
        [
            document.querySelector(`[id='${d}']`),
            ...Oe
        ].some((e)=>null == e ? void 0 : e.contains(o)) || ($e(!1), R(ae));
    }, We = _(ze, 50, !0), Pe = _(De, 50, !0), Ve = (e)=>{
        Pe.cancel(), We(e);
    }, Fe = ()=>{
        We.cancel(), Pe();
    }, Ke = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useCallback"])(()=>{
        var e, t;
        const o = null !== (e = null == we ? void 0 : we.position) && void 0 !== e ? e : F;
        o ? qe(o) : T ? ge.current && qe(ge.current) : (null == ee ? void 0 : ee.isConnected) && E({
            place: null !== (t = null == we ? void 0 : we.place) && void 0 !== t ? t : v,
            offset: m,
            elementReference: ee,
            tooltipReference: ce.current,
            tooltipArrowReference: se.current,
            strategy: b,
            middlewares: S,
            border: oe
        }).then((e)=>{
            Te.current && Ie(e);
        });
    }, [
        me,
        ee,
        Y,
        V,
        v,
        null == we ? void 0 : we.place,
        m,
        b,
        F,
        null == we ? void 0 : we.position,
        T
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        var e, t;
        const o = new Set(Ee);
        Oe.forEach((e)=>{
            (null == X ? void 0 : X(e)) || o.add({
                current: e
            });
        });
        const l = document.querySelector(`[id='${d}']`);
        l && !(null == X ? void 0 : X(l)) && o.add({
            current: l
        });
        const r = ()=>{
            $e(!1);
        }, n = L(ee), i = L(ce.current);
        Ne.scroll && (window.addEventListener("scroll", r), null == n || n.addEventListener("scroll", r), null == i || i.addEventListener("scroll", r));
        let c = null;
        Ne.resize ? window.addEventListener("resize", r) : ee && ce.current && (c = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$dom$2f$dist$2f$floating$2d$ui$2e$dom$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["autoUpdate"])(ee, ce.current, Ke, {
            ancestorResize: !0,
            elementResize: !0,
            layoutShift: !0
        }));
        const s = (e)=>{
            "Escape" === e.key && $e(!1);
        };
        Ne.escape && window.addEventListener("keydown", s), Ne.clickOutsideAnchor && window.addEventListener("click", Me);
        const a = [], u = (e)=>{
            me && (null == e ? void 0 : e.target) === ee || ze(e);
        }, p = (e)=>{
            me && (null == e ? void 0 : e.target) === ee && De();
        }, v = [
            "mouseover",
            "mouseout",
            "mouseenter",
            "mouseleave",
            "focus",
            "blur"
        ], m = [
            "click",
            "dblclick",
            "mousedown",
            "mouseup"
        ];
        Object.entries(Re).forEach(([e, t])=>{
            t && (v.includes(e) ? a.push({
                event: e,
                listener: Ve
            }) : m.includes(e) && a.push({
                event: e,
                listener: u
            }));
        }), Object.entries(xe).forEach(([e, t])=>{
            t && (v.includes(e) ? a.push({
                event: e,
                listener: Fe
            }) : m.includes(e) && a.push({
                event: e,
                listener: p
            }));
        }), T && a.push({
            event: "pointermove",
            listener: He
        });
        const y = ()=>{
            _e.current = !0;
        }, h = ()=>{
            _e.current = !1, De();
        };
        return $ && !Ce && (null === (e = ce.current) || void 0 === e || e.addEventListener("mouseenter", y), null === (t = ce.current) || void 0 === t || t.addEventListener("mouseleave", h)), a.forEach(({ event: e, listener: t })=>{
            o.forEach((o)=>{
                var l;
                null === (l = o.current) || void 0 === l || l.addEventListener(e, t);
            });
        }), ()=>{
            var e, t;
            Ne.scroll && (window.removeEventListener("scroll", r), null == n || n.removeEventListener("scroll", r), null == i || i.removeEventListener("scroll", r)), Ne.resize ? window.removeEventListener("resize", r) : null == c || c(), Ne.clickOutsideAnchor && window.removeEventListener("click", Me), Ne.escape && window.removeEventListener("keydown", s), $ && !Ce && (null === (e = ce.current) || void 0 === e || e.removeEventListener("mouseenter", y), null === (t = ce.current) || void 0 === t || t.removeEventListener("mouseleave", h)), a.forEach(({ event: e, listener: t })=>{
                o.forEach((o)=>{
                    var l;
                    null === (l = o.current) || void 0 === l || l.removeEventListener(e, t);
                });
            });
        };
    }, [
        ee,
        Ke,
        ye,
        Ee,
        Oe,
        H,
        M,
        W,
        Le,
        A,
        O
    ]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        var e, t;
        let o = null !== (t = null !== (e = null == we ? void 0 : we.anchorSelect) && void 0 !== e ? e : p) && void 0 !== t ? t : "";
        !o && l && (o = `[data-tooltip-id='${l.replace(/'/g, "\\'")}']`);
        const r = new MutationObserver((e)=>{
            const t = [], r = [];
            e.forEach((e)=>{
                if ("attributes" === e.type && "data-tooltip-id" === e.attributeName) {
                    e.target.getAttribute("data-tooltip-id") === l ? t.push(e.target) : e.oldValue === l && r.push(e.target);
                }
                if ("childList" === e.type) {
                    if (ee) {
                        const t = [
                            ...e.removedNodes
                        ].filter((e)=>1 === e.nodeType);
                        if (o) try {
                            r.push(...t.filter((e)=>e.matches(o))), r.push(...t.flatMap((e)=>[
                                    ...e.querySelectorAll(o)
                                ]));
                        } catch (e) {}
                        t.some((e)=>{
                            var t;
                            return !!(null === (t = null == e ? void 0 : e.contains) || void 0 === t ? void 0 : t.call(e, ee)) && (he(!1), $e(!1), te(null), R(ae), R(ue), !0);
                        });
                    }
                    if (o) try {
                        const l = [
                            ...e.addedNodes
                        ].filter((e)=>1 === e.nodeType);
                        t.push(...l.filter((e)=>e.matches(o))), t.push(...l.flatMap((e)=>[
                                ...e.querySelectorAll(o)
                            ]));
                    } catch (e) {}
                }
            }), (t.length || r.length) && ke((e)=>[
                    ...e.filter((e)=>!r.includes(e)),
                    ...t
                ]);
        });
        return r.observe(document.body, {
            childList: !0,
            subtree: !0,
            attributes: !0,
            attributeFilter: [
                "data-tooltip-id"
            ],
            attributeOldValue: !0
        }), ()=>{
            r.disconnect();
        };
    }, [
        l,
        p,
        null == we ? void 0 : we.anchorSelect,
        ee
    ]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        Ke();
    }, [
        Ke
    ]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        if (!(null == G ? void 0 : G.current)) return ()=>null;
        const e = new ResizeObserver(()=>{
            setTimeout(()=>Ke());
        });
        return e.observe(G.current), ()=>{
            e.disconnect();
        };
    }, [
        Y,
        null == G ? void 0 : G.current
    ]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        var e;
        const t = document.querySelector(`[id='${d}']`), o = [
            ...Oe,
            t
        ];
        ee && o.includes(ee) || te(null !== (e = Oe[0]) && void 0 !== e ? e : t);
    }, [
        d,
        Oe,
        ee
    ]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useEffect"])(()=>(J && $e(!0), ()=>{
            R(ae), R(ue);
        }), []), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        var e;
        let t = null !== (e = null == we ? void 0 : we.anchorSelect) && void 0 !== e ? e : p;
        if (!t && l && (t = `[data-tooltip-id='${l.replace(/'/g, "\\'")}']`), t) try {
            const e = Array.from(document.querySelectorAll(t));
            ke(e);
        } catch (e) {
            ke([]);
        }
    }, [
        l,
        p,
        null == we ? void 0 : we.anchorSelect
    ]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        ae.current && (R(ae), je(A));
    }, [
        A
    ]);
    const Ue = null !== (ie = null == we ? void 0 : we.content) && void 0 !== ie ? ie : Y, Xe = me && Object.keys(pe.tooltipStyles).length > 0;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useImperativeHandle"])(t, ()=>({
            open: (e)=>{
                if (null == e ? void 0 : e.anchorSelect) try {
                    document.querySelector(e.anchorSelect);
                } catch (t) {
                    return void console.warn(`[react-tooltip] "${e.anchorSelect}" is not a valid CSS selector`);
                }
                be(null != e ? e : null), (null == e ? void 0 : e.delay) ? je(e.delay) : $e(!0);
            },
            close: (e)=>{
                (null == e ? void 0 : e.delay) ? Be(e.delay) : $e(!1);
            },
            activeAnchor: ee,
            place: pe.place,
            isOpen: Boolean(ye && !x && Ue && Xe)
        })), ye && !x && Ue ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].createElement(g, {
        id: l,
        role: ne,
        className: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$classnames$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])("react-tooltip", z.tooltip, D.tooltip, D[u], i, `react-tooltip__place-${pe.place}`, z[Xe ? "show" : "closing"], Xe ? "react-tooltip__show" : "react-tooltip__closing", "fixed" === b && z.fixed, $ && z.clickable),
        onTransitionEnd: (e)=>{
            R(de), me || "opacity" !== e.propertyName || (he(!1), be(null), null == U || U());
        },
        style: {
            ...V,
            ...pe.tooltipStyles,
            opacity: void 0 !== le && Xe ? le : void 0
        },
        ref: ce
    }, Ue, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].createElement(g, {
        className: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$classnames$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])("react-tooltip-arrow", z.arrow, D.arrow, c, N && z.noArrow),
        style: {
            ...pe.tooltipArrowStyles,
            background: re ? `linear-gradient(to right bottom, transparent 50%, ${re} 50%)` : void 0
        },
        ref: se
    })) : null;
}, H = ({ content: t })=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].createElement("span", {
        dangerouslySetInnerHTML: {
            __html: t
        }
    }), M = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].forwardRef(({ id: t, anchorId: l, anchorSelect: n, content: i, html: c, render: a, className: u, classNameArrow: d, variant: p = "dark", place: v = "top", offset: m = 10, wrapper: f = "div", children: h = null, events: w = [
    "hover"
], openOnClick: b = !1, positionStrategy: S = "absolute", middlewares: g, delayShow: E = 0, delayHide: _ = 0, float: O = !1, hidden: k = !1, noArrow: T = !1, clickable: L = !1, closeOnEsc: C = !1, closeOnScroll: R = !1, closeOnResize: x = !1, openEvents: N, closeEvents: $, globalCloseEvents: I, imperativeModeOnly: B = !1, style: z, position: D, isOpen: M, defaultIsOpen: W = !1, disableStyleInjection: P = !1, border: V, opacity: F, arrowColor: K, setIsOpen: U, afterShow: X, afterHide: Y, disableTooltip: G, role: Z = "tooltip" }, J)=>{
    const [Q, ee] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useState"])(i), [te, oe] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useState"])(c), [le, re] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useState"])(v), [ne, ie] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useState"])(p), [ce, se] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useState"])(m), [ae, ue] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useState"])(E), [de, pe] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useState"])(_), [ve, me] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useState"])(O), [fe, ye] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useState"])(k), [he, we] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useState"])(f), [be, Se] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useState"])(w), [ge, Ee] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useState"])(S), [Ae, _e] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useState"])(null), [Oe, ke] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useState"])(null), Te = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useRef"])(P), { anchorRefs: Le, activeAnchor: Ce } = j(t), Re = (e)=>null == e ? void 0 : e.getAttributeNames().reduce((t, o)=>{
            var l;
            if (o.startsWith("data-tooltip-")) {
                t[o.replace(/^data-tooltip-/, "")] = null !== (l = null == e ? void 0 : e.getAttribute(o)) && void 0 !== l ? l : null;
            }
            return t;
        }, {}), xe = (e)=>{
        const t = {
            place: (e)=>{
                var t;
                re(null !== (t = e) && void 0 !== t ? t : v);
            },
            content: (e)=>{
                ee(null != e ? e : i);
            },
            html: (e)=>{
                oe(null != e ? e : c);
            },
            variant: (e)=>{
                var t;
                ie(null !== (t = e) && void 0 !== t ? t : p);
            },
            offset: (e)=>{
                se(null === e ? m : Number(e));
            },
            wrapper: (e)=>{
                var t;
                we(null !== (t = e) && void 0 !== t ? t : f);
            },
            events: (e)=>{
                const t = null == e ? void 0 : e.split(" ");
                Se(null != t ? t : w);
            },
            "position-strategy": (e)=>{
                var t;
                Ee(null !== (t = e) && void 0 !== t ? t : S);
            },
            "delay-show": (e)=>{
                ue(null === e ? E : Number(e));
            },
            "delay-hide": (e)=>{
                pe(null === e ? _ : Number(e));
            },
            float: (e)=>{
                me(null === e ? O : "true" === e);
            },
            hidden: (e)=>{
                ye(null === e ? k : "true" === e);
            },
            "class-name": (e)=>{
                _e(e);
            }
        };
        Object.values(t).forEach((e)=>e(null)), Object.entries(e).forEach(([e, o])=>{
            var l;
            null === (l = t[e]) || void 0 === l || l.call(t, o);
        });
    };
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        ee(i);
    }, [
        i
    ]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        oe(c);
    }, [
        c
    ]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        re(v);
    }, [
        v
    ]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        ie(p);
    }, [
        p
    ]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        se(m);
    }, [
        m
    ]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        ue(E);
    }, [
        E
    ]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        pe(_);
    }, [
        _
    ]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        me(O);
    }, [
        O
    ]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        ye(k);
    }, [
        k
    ]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        Ee(S);
    }, [
        S
    ]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        Te.current !== P && console.warn("[react-tooltip] Do not change `disableStyleInjection` dynamically.");
    }, [
        P
    ]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        "undefined" != typeof window && window.dispatchEvent(new CustomEvent("react-tooltip-inject-styles", {
            detail: {
                disableCore: "core" === P,
                disableBase: P
            }
        }));
    }, []), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        var e;
        const o = new Set(Le);
        let r = n;
        if (!r && t && (r = `[data-tooltip-id='${t.replace(/'/g, "\\'")}']`), r) try {
            document.querySelectorAll(r).forEach((e)=>{
                o.add({
                    current: e
                });
            });
        } catch (e) {
            console.warn(`[react-tooltip] "${r}" is not a valid CSS selector`);
        }
        const i = document.querySelector(`[id='${l}']`);
        if (i && o.add({
            current: i
        }), !o.size) return ()=>null;
        const c = null !== (e = null != Oe ? Oe : i) && void 0 !== e ? e : Ce.current, s = new MutationObserver((e)=>{
            e.forEach((e)=>{
                var t;
                if (!c || "attributes" !== e.type || !(null === (t = e.attributeName) || void 0 === t ? void 0 : t.startsWith("data-tooltip-"))) return;
                const o = Re(c);
                xe(o);
            });
        }), a = {
            attributes: !0,
            childList: !1,
            subtree: !1
        };
        if (c) {
            const e = Re(c);
            xe(e), s.observe(c, a);
        }
        return ()=>{
            s.disconnect();
        };
    }, [
        Le,
        Ce,
        Oe,
        l,
        n
    ]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        (null == z ? void 0 : z.border) && console.warn("[react-tooltip] Do not set `style.border`. Use `border` prop instead."), V && !A("border", `${V}`) && console.warn(`[react-tooltip] "${V}" is not a valid \`border\`.`), (null == z ? void 0 : z.opacity) && console.warn("[react-tooltip] Do not set `style.opacity`. Use `opacity` prop instead."), F && !A("opacity", `${F}`) && console.warn(`[react-tooltip] "${F}" is not a valid \`opacity\`.`);
    }, []);
    let Ne = h;
    const $e = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useRef"])(null);
    if (a) {
        const t = a({
            content: (null == Oe ? void 0 : Oe.getAttribute("data-tooltip-content")) || Q || null,
            activeAnchor: Oe
        });
        Ne = t ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].createElement("div", {
            ref: $e,
            className: "react-tooltip-content-wrapper"
        }, t) : null;
    } else Q && (Ne = Q);
    te && (Ne = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].createElement(H, {
        content: te
    }));
    const Ie = {
        forwardRef: J,
        id: t,
        anchorId: l,
        anchorSelect: n,
        className: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$classnames$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"])(u, Ae),
        classNameArrow: d,
        content: Ne,
        contentWrapperRef: $e,
        place: le,
        variant: ne,
        offset: ce,
        wrapper: he,
        events: be,
        openOnClick: b,
        positionStrategy: ge,
        middlewares: g,
        delayShow: ae,
        delayHide: de,
        float: ve,
        hidden: fe,
        noArrow: T,
        clickable: L,
        closeOnEsc: C,
        closeOnScroll: R,
        closeOnResize: x,
        openEvents: N,
        closeEvents: $,
        globalCloseEvents: I,
        imperativeModeOnly: B,
        style: z,
        position: D,
        isOpen: M,
        defaultIsOpen: W,
        border: V,
        opacity: F,
        arrowColor: K,
        setIsOpen: U,
        afterShow: X,
        afterHide: Y,
        disableTooltip: G,
        activeAnchor: Oe,
        setActiveAnchor: (e)=>ke(e),
        role: Z
    };
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["default"].createElement(q, {
        ...Ie
    });
});
"undefined" != typeof window && window.addEventListener("react-tooltip-inject-styles", (e)=>{
    e.detail.disableCore || S({
        css: `:root{--rt-color-white:#fff;--rt-color-dark:#222;--rt-color-success:#8dc572;--rt-color-error:#be6464;--rt-color-warning:#f0ad4e;--rt-color-info:#337ab7;--rt-opacity:0.9;--rt-transition-show-delay:0.15s;--rt-transition-closing-delay:0.15s}.core-styles-module_tooltip__3vRRp{position:absolute;top:0;left:0;pointer-events:none;opacity:0;will-change:opacity}.core-styles-module_fixed__pcSol{position:fixed}.core-styles-module_arrow__cvMwQ{position:absolute;background:inherit}.core-styles-module_noArrow__xock6{display:none}.core-styles-module_clickable__ZuTTB{pointer-events:auto}.core-styles-module_show__Nt9eE{opacity:var(--rt-opacity);transition:opacity var(--rt-transition-show-delay)ease-out}.core-styles-module_closing__sGnxF{opacity:0;transition:opacity var(--rt-transition-closing-delay)ease-in}`,
        type: "core"
    }), e.detail.disableBase || S({
        css: `
.styles-module_tooltip__mnnfp{padding:8px 16px;border-radius:3px;font-size:90%;width:max-content}.styles-module_arrow__K0L3T{width:8px;height:8px}[class*='react-tooltip__place-top']>.styles-module_arrow__K0L3T{transform:rotate(45deg)}[class*='react-tooltip__place-right']>.styles-module_arrow__K0L3T{transform:rotate(135deg)}[class*='react-tooltip__place-bottom']>.styles-module_arrow__K0L3T{transform:rotate(225deg)}[class*='react-tooltip__place-left']>.styles-module_arrow__K0L3T{transform:rotate(315deg)}.styles-module_dark__xNqje{background:var(--rt-color-dark);color:var(--rt-color-white)}.styles-module_light__Z6W-X{background-color:var(--rt-color-white);color:var(--rt-color-dark)}.styles-module_success__A2AKt{background-color:var(--rt-color-success);color:var(--rt-color-white)}.styles-module_warning__SCK0X{background-color:var(--rt-color-warning);color:var(--rt-color-white)}.styles-module_error__JvumD{background-color:var(--rt-color-error);color:var(--rt-color-white)}.styles-module_info__BWdHW{background-color:var(--rt-color-info);color:var(--rt-color-white)}`,
        type: "base"
    });
});
;
}}),
"[project]/node_modules/arrows-svg/dist/main.js [client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
!function(e, t) {
    if ("TURBOPACK compile-time truthy", 1) module.exports = t();
    else {
        "TURBOPACK unreachable";
        var n;
        var r;
    }
}(self, ()=>(()=>{
        "use strict";
        var e = {
            400: (e, t, n)=>{
                n.r(t), n.d(t, {
                    Component: ()=>g,
                    Fragment: ()=>m,
                    cloneElement: ()=>U,
                    createContext: ()=>B,
                    createElement: ()=>p,
                    createRef: ()=>y,
                    h: ()=>p,
                    hydrate: ()=>F,
                    isValidElement: ()=>u,
                    options: ()=>o,
                    render: ()=>R,
                    toChildArray: ()=>A
                });
                var r, o, i, u, _, a, l, c = {}, f = [], s = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
                function d(e, t) {
                    for(var n in t)e[n] = t[n];
                    return e;
                }
                function h(e) {
                    var t = e.parentNode;
                    t && t.removeChild(e);
                }
                function p(e, t, n) {
                    var o, i, u, _ = {};
                    for(u in t)"key" == u ? o = t[u] : "ref" == u ? i = t[u] : _[u] = t[u];
                    if (arguments.length > 2 && (_.children = arguments.length > 3 ? r.call(arguments, 2) : n), "function" == typeof e && null != e.defaultProps) for(u in e.defaultProps)void 0 === _[u] && (_[u] = e.defaultProps[u]);
                    return v(e, _, o, i, null);
                }
                function v(e, t, n, r, u) {
                    var _ = {
                        type: e,
                        props: t,
                        key: n,
                        ref: r,
                        __k: null,
                        __: null,
                        __b: 0,
                        __e: null,
                        __d: void 0,
                        __c: null,
                        __h: null,
                        constructor: void 0,
                        __v: null == u ? ++i : u
                    };
                    return null == u && null != o.vnode && o.vnode(_), _;
                }
                function y() {
                    return {
                        current: null
                    };
                }
                function m(e) {
                    return e.children;
                }
                function g(e, t) {
                    this.props = e, this.context = t;
                }
                function b(e, t) {
                    if (null == t) return e.__ ? b(e.__, e.__.__k.indexOf(e) + 1) : null;
                    for(var n; t < e.__k.length; t++)if (null != (n = e.__k[t]) && null != n.__e) return n.__e;
                    return "function" == typeof e.type ? b(e) : null;
                }
                function T(e) {
                    var t, n;
                    if (null != (e = e.__) && null != e.__c) {
                        for(e.__e = e.__c.base = null, t = 0; t < e.__k.length; t++)if (null != (n = e.__k[t]) && null != n.__e) {
                            e.__e = e.__c.base = n.__e;
                            break;
                        }
                        return T(e);
                    }
                }
                function O(e) {
                    (!e.__d && (e.__d = !0) && _.push(e) && !w.__r++ || a !== o.debounceRendering) && ((a = o.debounceRendering) || setTimeout)(w);
                }
                function w() {
                    for(var e; w.__r = _.length;)e = _.sort(function(e, t) {
                        return e.__v.__b - t.__v.__b;
                    }), _ = [], e.some(function(e) {
                        var t, n, r, o, i, u;
                        e.__d && (i = (o = (t = e).__v).__e, (u = t.__P) && (n = [], (r = d({}, o)).__v = o.__v + 1, I(u, o, r, t.__n, void 0 !== u.ownerSVGElement, null != o.__h ? [
                            i
                        ] : null, n, null == i ? b(o) : i, o.__h), S(n, o), o.__e != i && T(o)));
                    });
                }
                function x(e, t, n, r, o, i, u, _, a, l) {
                    var s, d, h, p, y, g, T, O = r && r.__k || f, w = O.length;
                    for(n.__k = [], s = 0; s < t.length; s++)if (null != (p = n.__k[s] = null == (p = t[s]) || "boolean" == typeof p ? null : "string" == typeof p || "number" == typeof p || "bigint" == typeof p ? v(null, p, null, null, p) : Array.isArray(p) ? v(m, {
                        children: p
                    }, null, null, null) : p.__b > 0 ? v(p.type, p.props, p.key, p.ref ? p.ref : null, p.__v) : p)) {
                        if (p.__ = n, p.__b = n.__b + 1, null === (h = O[s]) || h && p.key == h.key && p.type === h.type) O[s] = void 0;
                        else for(d = 0; d < w; d++){
                            if ((h = O[d]) && p.key == h.key && p.type === h.type) {
                                O[d] = void 0;
                                break;
                            }
                            h = null;
                        }
                        I(e, p, h = h || c, o, i, u, _, a, l), y = p.__e, (d = p.ref) && h.ref != d && (T || (T = []), h.ref && T.push(h.ref, null, p), T.push(d, p.__c || y, p)), null != y ? (null == g && (g = y), "function" == typeof p.type && p.__k === h.__k ? p.__d = a = E(p, a, e) : a = P(e, p, h, O, y, a), "function" == typeof n.type && (n.__d = a)) : a && h.__e == a && a.parentNode != e && (a = b(h));
                    }
                    for(n.__e = g, s = w; s--;)null != O[s] && k(O[s], O[s]);
                    if (T) for(s = 0; s < T.length; s++)j(T[s], T[++s], T[++s]);
                }
                function E(e, t, n) {
                    for(var r, o = e.__k, i = 0; o && i < o.length; i++)(r = o[i]) && (r.__ = e, t = "function" == typeof r.type ? E(r, t, n) : P(n, r, r, o, r.__e, t));
                    return t;
                }
                function A(e, t) {
                    return t = t || [], null == e || "boolean" == typeof e || (Array.isArray(e) ? e.some(function(e) {
                        A(e, t);
                    }) : t.push(e)), t;
                }
                function P(e, t, n, r, o, i) {
                    var u, _, a;
                    if (void 0 !== t.__d) u = t.__d, t.__d = void 0;
                    else if (null == n || o != i || null == o.parentNode) e: if (null == i || i.parentNode !== e) e.appendChild(o), u = null;
                    else {
                        for(_ = i, a = 0; (_ = _.nextSibling) && a < r.length; a += 1)if (_ == o) break e;
                        e.insertBefore(o, i), u = i;
                    }
                    return void 0 !== u ? u : o.nextSibling;
                }
                function M(e, t, n) {
                    "-" === t[0] ? e.setProperty(t, n) : e[t] = null == n ? "" : "number" != typeof n || s.test(t) ? n : n + "px";
                }
                function C(e, t, n, r, o) {
                    var i;
                    e: if ("style" === t) if ("string" == typeof n) e.style.cssText = n;
                    else {
                        if ("string" == typeof r && (e.style.cssText = r = ""), r) for(t in r)n && t in n || M(e.style, t, "");
                        if (n) for(t in n)r && n[t] === r[t] || M(e.style, t, n[t]);
                    }
                    else if ("o" === t[0] && "n" === t[1]) i = t !== (t = t.replace(/Capture$/, "")), t = t.toLowerCase() in e ? t.toLowerCase().slice(2) : t.slice(2), e.l || (e.l = {}), e.l[t + i] = n, n ? r || e.addEventListener(t, i ? H : D, i) : e.removeEventListener(t, i ? H : D, i);
                    else if ("dangerouslySetInnerHTML" !== t) {
                        if (o) t = t.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
                        else if ("href" !== t && "list" !== t && "form" !== t && "tabIndex" !== t && "download" !== t && t in e) try {
                            e[t] = null == n ? "" : n;
                            break e;
                        } catch (e) {}
                        "function" == typeof n || (null == n || !1 === n && -1 == t.indexOf("-") ? e.removeAttribute(t) : e.setAttribute(t, n));
                    }
                }
                function D(e) {
                    this.l[e.type + !1](o.event ? o.event(e) : e);
                }
                function H(e) {
                    this.l[e.type + !0](o.event ? o.event(e) : e);
                }
                function I(e, t, n, r, i, u, _, a, l) {
                    var c, f, s, h, p, v, y, b, T, O, w, E, A, P, M, C = t.type;
                    if (void 0 !== t.constructor) return null;
                    null != n.__h && (l = n.__h, a = t.__e = n.__e, t.__h = null, u = [
                        a
                    ]), (c = o.__b) && c(t);
                    try {
                        e: if ("function" == typeof C) {
                            if (b = t.props, T = (c = C.contextType) && r[c.__c], O = c ? T ? T.props.value : c.__ : r, n.__c ? y = (f = t.__c = n.__c).__ = f.__E : ("prototype" in C && C.prototype.render ? t.__c = f = new C(b, O) : (t.__c = f = new g(b, O), f.constructor = C, f.render = L), T && T.sub(f), f.props = b, f.state || (f.state = {}), f.context = O, f.__n = r, s = f.__d = !0, f.__h = [], f._sb = []), null == f.__s && (f.__s = f.state), null != C.getDerivedStateFromProps && (f.__s == f.state && (f.__s = d({}, f.__s)), d(f.__s, C.getDerivedStateFromProps(b, f.__s))), h = f.props, p = f.state, s) null == C.getDerivedStateFromProps && null != f.componentWillMount && f.componentWillMount(), null != f.componentDidMount && f.__h.push(f.componentDidMount);
                            else {
                                if (null == C.getDerivedStateFromProps && b !== h && null != f.componentWillReceiveProps && f.componentWillReceiveProps(b, O), !f.__e && null != f.shouldComponentUpdate && !1 === f.shouldComponentUpdate(b, f.__s, O) || t.__v === n.__v) {
                                    for(f.props = b, f.state = f.__s, t.__v !== n.__v && (f.__d = !1), f.__v = t, t.__e = n.__e, t.__k = n.__k, t.__k.forEach(function(e) {
                                        e && (e.__ = t);
                                    }), w = 0; w < f._sb.length; w++)f.__h.push(f._sb[w]);
                                    f._sb = [], f.__h.length && _.push(f);
                                    break e;
                                }
                                null != f.componentWillUpdate && f.componentWillUpdate(b, f.__s, O), null != f.componentDidUpdate && f.__h.push(function() {
                                    f.componentDidUpdate(h, p, v);
                                });
                            }
                            if (f.context = O, f.props = b, f.__v = t, f.__P = e, E = o.__r, A = 0, "prototype" in C && C.prototype.render) {
                                for(f.state = f.__s, f.__d = !1, E && E(t), c = f.render(f.props, f.state, f.context), P = 0; P < f._sb.length; P++)f.__h.push(f._sb[P]);
                                f._sb = [];
                            } else do {
                                f.__d = !1, E && E(t), c = f.render(f.props, f.state, f.context), f.state = f.__s;
                            }while (f.__d && ++A < 25)
                            f.state = f.__s, null != f.getChildContext && (r = d(d({}, r), f.getChildContext())), s || null == f.getSnapshotBeforeUpdate || (v = f.getSnapshotBeforeUpdate(h, p)), M = null != c && c.type === m && null == c.key ? c.props.children : c, x(e, Array.isArray(M) ? M : [
                                M
                            ], t, n, r, i, u, _, a, l), f.base = t.__e, t.__h = null, f.__h.length && _.push(f), y && (f.__E = f.__ = null), f.__e = !1;
                        } else null == u && t.__v === n.__v ? (t.__k = n.__k, t.__e = n.__e) : t.__e = N(n.__e, t, n, r, i, u, _, l);
                        (c = o.diffed) && c(t);
                    } catch (e) {
                        t.__v = null, (l || null != u) && (t.__e = a, t.__h = !!l, u[u.indexOf(a)] = null), o.__e(e, t, n);
                    }
                }
                function S(e, t) {
                    o.__c && o.__c(t, e), e.some(function(t) {
                        try {
                            e = t.__h, t.__h = [], e.some(function(e) {
                                e.call(t);
                            });
                        } catch (e) {
                            o.__e(e, t.__v);
                        }
                    });
                }
                function N(e, t, n, o, i, u, _, a) {
                    var l, f, s, d = n.props, p = t.props, v = t.type, y = 0;
                    if ("svg" === v && (i = !0), null != u) {
                        for(; y < u.length; y++)if ((l = u[y]) && "setAttribute" in l == !!v && (v ? l.localName === v : 3 === l.nodeType)) {
                            e = l, u[y] = null;
                            break;
                        }
                    }
                    if (null == e) {
                        if (null === v) return document.createTextNode(p);
                        e = i ? document.createElementNS("http://www.w3.org/2000/svg", v) : document.createElement(v, p.is && p), u = null, a = !1;
                    }
                    if (null === v) d === p || a && e.data === p || (e.data = p);
                    else {
                        if (u = u && r.call(e.childNodes), f = (d = n.props || c).dangerouslySetInnerHTML, s = p.dangerouslySetInnerHTML, !a) {
                            if (null != u) for(d = {}, y = 0; y < e.attributes.length; y++)d[e.attributes[y].name] = e.attributes[y].value;
                            (s || f) && (s && (f && s.__html == f.__html || s.__html === e.innerHTML) || (e.innerHTML = s && s.__html || ""));
                        }
                        if (function(e, t, n, r, o) {
                            var i;
                            for(i in n)"children" === i || "key" === i || i in t || C(e, i, null, n[i], r);
                            for(i in t)o && "function" != typeof t[i] || "children" === i || "key" === i || "value" === i || "checked" === i || n[i] === t[i] || C(e, i, t[i], n[i], r);
                        }(e, p, d, i, a), s) t.__k = [];
                        else if (y = t.props.children, x(e, Array.isArray(y) ? y : [
                            y
                        ], t, n, o, i && "foreignObject" !== v, u, _, u ? u[0] : n.__k && b(n, 0), a), null != u) for(y = u.length; y--;)null != u[y] && h(u[y]);
                        a || ("value" in p && void 0 !== (y = p.value) && (y !== e.value || "progress" === v && !y || "option" === v && y !== d.value) && C(e, "value", y, d.value, !1), "checked" in p && void 0 !== (y = p.checked) && y !== e.checked && C(e, "checked", y, d.checked, !1));
                    }
                    return e;
                }
                function j(e, t, n) {
                    try {
                        "function" == typeof e ? e(t) : e.current = t;
                    } catch (e) {
                        o.__e(e, n);
                    }
                }
                function k(e, t, n) {
                    var r, i;
                    if (o.unmount && o.unmount(e), (r = e.ref) && (r.current && r.current !== e.__e || j(r, null, t)), null != (r = e.__c)) {
                        if (r.componentWillUnmount) try {
                            r.componentWillUnmount();
                        } catch (e) {
                            o.__e(e, t);
                        }
                        r.base = r.__P = null, e.__c = void 0;
                    }
                    if (r = e.__k) for(i = 0; i < r.length; i++)r[i] && k(r[i], t, n || "function" != typeof e.type);
                    n || null == e.__e || h(e.__e), e.__ = e.__e = e.__d = void 0;
                }
                function L(e, t, n) {
                    return this.constructor(e, n);
                }
                function R(e, t, n) {
                    var i, u, _;
                    o.__ && o.__(e, t), u = (i = "function" == typeof n) ? null : n && n.__k || t.__k, _ = [], I(t, e = (!i && n || t).__k = p(m, null, [
                        e
                    ]), u || c, c, void 0 !== t.ownerSVGElement, !i && n ? [
                        n
                    ] : u ? null : t.firstChild ? r.call(t.childNodes) : null, _, !i && n ? n : u ? u.__e : t.firstChild, i), S(_, e);
                }
                function F(e, t) {
                    R(e, t, F);
                }
                function U(e, t, n) {
                    var o, i, u, _ = d({}, e.props);
                    for(u in t)"key" == u ? o = t[u] : "ref" == u ? i = t[u] : _[u] = t[u];
                    return arguments.length > 2 && (_.children = arguments.length > 3 ? r.call(arguments, 2) : n), v(e.type, _, o || e.key, i || e.ref, null);
                }
                function B(e, t) {
                    var n = {
                        __c: t = "__cC" + l++,
                        __: e,
                        Consumer: function(e, t) {
                            return e.children(t);
                        },
                        Provider: function(e) {
                            var n, r;
                            return this.getChildContext || (n = [], (r = {})[t] = this, this.getChildContext = function() {
                                return r;
                            }, this.shouldComponentUpdate = function(e) {
                                this.props.value !== e.value && n.some(O);
                            }, this.sub = function(e) {
                                n.push(e);
                                var t = e.componentWillUnmount;
                                e.componentWillUnmount = function() {
                                    n.splice(n.indexOf(e), 1), t && t.call(e);
                                };
                            }), e.children;
                        }
                    };
                    return n.Provider.__ = n.Consumer.contextType = n;
                }
                r = f.slice, o = {
                    __e: function(e, t, n, r) {
                        for(var o, i, u; t = t.__;)if ((o = t.__c) && !o.__) try {
                            if ((i = o.constructor) && null != i.getDerivedStateFromError && (o.setState(i.getDerivedStateFromError(e)), u = o.__d), null != o.componentDidCatch && (o.componentDidCatch(e, r || {}), u = o.__d), u) return o.__E = o;
                        } catch (t) {
                            e = t;
                        }
                        throw e;
                    }
                }, i = 0, u = function(e) {
                    return null != e && void 0 === e.constructor;
                }, g.prototype.setState = function(e, t) {
                    var n;
                    n = null != this.__s && this.__s !== this.state ? this.__s : this.__s = d({}, this.state), "function" == typeof e && (e = e(d({}, n), this.props)), e && d(n, e), null != e && this.__v && (t && this._sb.push(t), O(this));
                }, g.prototype.forceUpdate = function(e) {
                    this.__v && (this.__e = !0, e && this.__h.push(e), O(this));
                }, g.prototype.render = m, _ = [], w.__r = 0, l = 0;
            },
            396: (e, t, n)=>{
                n.r(t), n.d(t, {
                    useCallback: ()=>x,
                    useContext: ()=>E,
                    useDebugValue: ()=>A,
                    useEffect: ()=>g,
                    useErrorBoundary: ()=>P,
                    useId: ()=>M,
                    useImperativeHandle: ()=>O,
                    useLayoutEffect: ()=>b,
                    useMemo: ()=>w,
                    useReducer: ()=>m,
                    useRef: ()=>T,
                    useState: ()=>y
                });
                var r, o, i, u, _ = n(400), a = 0, l = [], c = [], f = _.options.__b, s = _.options.__r, d = _.options.diffed, h = _.options.__c, p = _.options.unmount;
                function v(e, t) {
                    _.options.__h && _.options.__h(o, e, a || t), a = 0;
                    var n = o.__H || (o.__H = {
                        __: [],
                        __h: []
                    });
                    return e >= n.__.length && n.__.push({
                        __V: c
                    }), n.__[e];
                }
                function y(e) {
                    return a = 1, m(j, e);
                }
                function m(e, t, n) {
                    var i = v(r++, 2);
                    if (i.t = e, !i.__c && (i.__ = [
                        n ? n(t) : j(void 0, t),
                        function(e) {
                            var t = i.__N ? i.__N[0] : i.__[0], n = i.t(t, e);
                            t !== n && (i.__N = [
                                n,
                                i.__[1]
                            ], i.__c.setState({}));
                        }
                    ], i.__c = o, !o.u)) {
                        o.u = !0;
                        var u = o.shouldComponentUpdate;
                        o.shouldComponentUpdate = function(e, t, n) {
                            if (!i.__c.__H) return !0;
                            var r = i.__c.__H.__.filter(function(e) {
                                return e.__c;
                            });
                            if (r.every(function(e) {
                                return !e.__N;
                            })) return !u || u.call(this, e, t, n);
                            var o = !1;
                            return r.forEach(function(e) {
                                if (e.__N) {
                                    var t = e.__[0];
                                    e.__ = e.__N, e.__N = void 0, t !== e.__[0] && (o = !0);
                                }
                            }), !(!o && i.__c.props === e) && (!u || u.call(this, e, t, n));
                        };
                    }
                    return i.__N || i.__;
                }
                function g(e, t) {
                    var n = v(r++, 3);
                    !_.options.__s && N(n.__H, t) && (n.__ = e, n.i = t, o.__H.__h.push(n));
                }
                function b(e, t) {
                    var n = v(r++, 4);
                    !_.options.__s && N(n.__H, t) && (n.__ = e, n.i = t, o.__h.push(n));
                }
                function T(e) {
                    return a = 5, w(function() {
                        return {
                            current: e
                        };
                    }, []);
                }
                function O(e, t, n) {
                    a = 6, b(function() {
                        return "function" == typeof e ? (e(t()), function() {
                            return e(null);
                        }) : e ? (e.current = t(), function() {
                            return e.current = null;
                        }) : void 0;
                    }, null == n ? n : n.concat(e));
                }
                function w(e, t) {
                    var n = v(r++, 7);
                    return N(n.__H, t) ? (n.__V = e(), n.i = t, n.__h = e, n.__V) : n.__;
                }
                function x(e, t) {
                    return a = 8, w(function() {
                        return e;
                    }, t);
                }
                function E(e) {
                    var t = o.context[e.__c], n = v(r++, 9);
                    return n.c = e, t ? (null == n.__ && (n.__ = !0, t.sub(o)), t.props.value) : e.__;
                }
                function A(e, t) {
                    _.options.useDebugValue && _.options.useDebugValue(t ? t(e) : e);
                }
                function P(e) {
                    var t = v(r++, 10), n = y();
                    return t.__ = e, o.componentDidCatch || (o.componentDidCatch = function(e, r) {
                        t.__ && t.__(e, r), n[1](e);
                    }), [
                        n[0],
                        function() {
                            n[1](void 0);
                        }
                    ];
                }
                function M() {
                    var e = v(r++, 11);
                    if (!e.__) {
                        for(var t = o.__v; null !== t && !t.__m && null !== t.__;)t = t.__;
                        var n = t.__m || (t.__m = [
                            0,
                            0
                        ]);
                        e.__ = "P" + n[0] + "-" + n[1]++;
                    }
                    return e.__;
                }
                function C() {
                    for(var e; e = l.shift();)if (e.__P && e.__H) try {
                        e.__H.__h.forEach(I), e.__H.__h.forEach(S), e.__H.__h = [];
                    } catch (t) {
                        e.__H.__h = [], _.options.__e(t, e.__v);
                    }
                }
                _.options.__b = function(e) {
                    o = null, f && f(e);
                }, _.options.__r = function(e) {
                    s && s(e), r = 0;
                    var t = (o = e.__c).__H;
                    t && (i === o ? (t.__h = [], o.__h = [], t.__.forEach(function(e) {
                        e.__N && (e.__ = e.__N), e.__V = c, e.__N = e.i = void 0;
                    })) : (t.__h.forEach(I), t.__h.forEach(S), t.__h = [])), i = o;
                }, _.options.diffed = function(e) {
                    d && d(e);
                    var t = e.__c;
                    t && t.__H && (t.__H.__h.length && (1 !== l.push(t) && u === _.options.requestAnimationFrame || ((u = _.options.requestAnimationFrame) || H)(C)), t.__H.__.forEach(function(e) {
                        e.i && (e.__H = e.i), e.__V !== c && (e.__ = e.__V), e.i = void 0, e.__V = c;
                    })), i = o = null;
                }, _.options.__c = function(e, t) {
                    t.some(function(e) {
                        try {
                            e.__h.forEach(I), e.__h = e.__h.filter(function(e) {
                                return !e.__ || S(e);
                            });
                        } catch (n) {
                            t.some(function(e) {
                                e.__h && (e.__h = []);
                            }), t = [], _.options.__e(n, e.__v);
                        }
                    }), h && h(e, t);
                }, _.options.unmount = function(e) {
                    p && p(e);
                    var t, n = e.__c;
                    n && n.__H && (n.__H.__.forEach(function(e) {
                        try {
                            I(e);
                        } catch (e) {
                            t = e;
                        }
                    }), n.__H = void 0, t && _.options.__e(t, n.__v));
                };
                var D = "function" == typeof requestAnimationFrame;
                function H(e) {
                    var t, n = function() {
                        clearTimeout(r), D && cancelAnimationFrame(t), setTimeout(e);
                    }, r = setTimeout(n, 100);
                    D && (t = requestAnimationFrame(n));
                }
                function I(e) {
                    var t = o, n = e.__c;
                    "function" == typeof n && (e.__c = void 0, n()), o = t;
                }
                function S(e) {
                    var t = o;
                    e.__c = e.__(), o = t;
                }
                function N(e, t) {
                    return !e || e.length !== t.length || t.some(function(t, n) {
                        return t !== e[n];
                    });
                }
                function j(e, t) {
                    return "function" == typeof t ? t(e) : t;
                }
            },
            515: function(e, t, n) {
                var r = this && this.__assign || function() {
                    return r = Object.assign || function(e) {
                        for(var t, n = 1, r = arguments.length; n < r; n++)for(var o in t = arguments[n])Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
                        return e;
                    }, r.apply(this, arguments);
                };
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.autoAnchorWithPoint = t.createAnchorWithPoint = t.castToAnchor = void 0;
                var o = n(773), i = n(312);
                t.castToAnchor = function(e) {
                    return "function" == typeof e || e instanceof HTMLElement ? {
                        node: e
                    } : e;
                }, t.createAnchorWithPoint = function(e) {
                    var n = t.castToAnchor(e), u = function(e) {
                        var t = o.default(e.node);
                        if (!t) throw new Error("Point is null or not contained by the document body. Check if 'from'/'to' exists, was added to the DOM (and not removed since).");
                        var n = t.getBoundingClientRect(), r = n.x || n.left, u = n.y || n.top;
                        switch(e.direction){
                            case i.DIRECTION.TOP_LEFT:
                                return {
                                    x: r,
                                    y: u
                                };
                            case i.DIRECTION.TOP:
                                return {
                                    x: r + n.width / 2,
                                    y: u
                                };
                            case i.DIRECTION.TOP_RIGHT:
                                return {
                                    x: r + n.width,
                                    y: u
                                };
                            case i.DIRECTION.RIGHT:
                                return {
                                    x: r + n.width,
                                    y: u + n.height / 2
                                };
                            case i.DIRECTION.BOTTOM_LEFT:
                                return {
                                    x: r,
                                    y: u + n.height
                                };
                            case i.DIRECTION.BOTTOM:
                                return {
                                    x: r + n.width / 2,
                                    y: u + n.height
                                };
                            case i.DIRECTION.BOTTOM_RIGHT:
                                return {
                                    x: r + n.width,
                                    y: u + n.height
                                };
                            case i.DIRECTION.LEFT:
                                return {
                                    x: r,
                                    y: u + n.height / 2
                                };
                            default:
                                return {
                                    x: r + n.width / 2,
                                    y: u + n.height / 2
                                };
                        }
                    }(n);
                    return r(r({}, n), u);
                }, t.autoAnchorWithPoint = function(e, n) {
                    if (e.translation && e.direction) return e;
                    var o = r({}, e), u = function(e, t) {
                        !function(e) {
                            o.direction || (o.direction = e);
                        }(e), function(e) {
                            o.translation || (o.translation = e);
                        }(t);
                    };
                    return Math.abs(e.x - n.x) > Math.abs(e.y - n.y) ? e.x < n.x ? u(i.DIRECTION.RIGHT, [
                        .3,
                        0
                    ]) : u(i.DIRECTION.LEFT, [
                        -.3,
                        0
                    ]) : e.y < n.y ? u(i.DIRECTION.BOTTOM, [
                        0,
                        .3
                    ]) : u(i.DIRECTION.TOP, [
                        0,
                        -.3
                    ]), t.createAnchorWithPoint(o);
                };
            },
            940: function(e, t, n) {
                var r = this && this.__assign || function() {
                    return r = Object.assign || function(e) {
                        for(var t, n = 1, r = arguments.length; n < r; n++)for(var o in t = arguments[n])Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
                        return e;
                    }, r.apply(this, arguments);
                };
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.Arrow = void 0;
                var o = n(400), i = n(396), u = n(296), _ = n(778), a = n(515), l = n(981);
                t.Arrow = function(e) {
                    var t = e.className, n = e.head, a = e.from, c = e.to, f = e.forwardRef, s = e.updateDelay, d = i.useState({
                        "useState[d]": function() {
                            return _.default(a, c, n);
                        }
                    }["useState[d]"]), h = d[0], p = d[1];
                    return i.useEffect(function() {
                        return u.default(a, c, {
                            update: function() {
                                return p(_.default(a, c, n));
                            },
                            updateDelay: s
                        }).clear;
                    }, [
                        a,
                        n,
                        c,
                        s
                    ]), o.h("svg", {
                        className: t,
                        style: {
                            top: h.offset.y,
                            left: h.offset.x,
                            position: "fixed"
                        },
                        width: h.size.width,
                        height: h.size.height,
                        ref: f
                    }, o.h("path", {
                        className: t + "__path",
                        d: h.pathCommands
                    }), h.heads.map(function(e) {
                        if (!e.node) return null;
                        var n = {
                            className: t + "__head " + t + "__head--" + e.id,
                            transform: l.headTransformCSS(e)
                        };
                        if ("string" == typeof e.node) return o.h("g", r({
                            key: e.id
                        }, n, {
                            dangerouslySetInnerHTML: {
                                __html: e.node
                            }
                        }));
                        var i = e.node;
                        return i.tagName ? o.h("g", r({}, n, {
                            dangerouslySetInnerHTML: {
                                __html: i.outerHTML
                            }
                        })) : o.h("g", r({
                            key: e.id
                        }, n), e.node);
                    }));
                }, t.default = function(e) {
                    var n = e.className, r = void 0 === n ? "arrow" : n, i = e.head, u = void 0 === i ? l.HEAD.THIN : i, _ = e.from, c = e.to, f = e.updateDelay, s = o.createRef(), d = document.createDocumentFragment();
                    if (!_) throw new Error("undefined from, try to pass it as from={() => ...}");
                    if (!c) throw new Error("undefined to, try to pass it as to={() => ...}");
                    return o.render(o.h(t.Arrow, {
                        className: r,
                        head: u,
                        from: a.castToAnchor(_),
                        to: a.castToAnchor(c),
                        forwardRef: s,
                        updateDelay: f
                    }), d), {
                        node: d,
                        clear: function() {
                            var e = s.current, t = e.parentNode;
                            t && t.removeChild(e);
                        }
                    };
                };
            },
            778: (e, t, n)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var r = n(515), o = n(240), i = n(981), u = n(945);
                t.default = function(e, t, n) {
                    var _ = i.prepareHeads(n), a = i.calculateHeadsPadding(_), l = r.createAnchorWithPoint(e), c = r.createAnchorWithPoint(t), f = o.produceContainer(r.autoAnchorWithPoint(l, c), r.autoAnchorWithPoint(c, l), a), s = u.pathListBezier(f, a), d = i.assignPathToHeads(_, s), h = u.convertPathToSVG(s), p = function(e, t) {
                        var n = u.pathReducer(e, function(e, t) {
                            return {
                                x: Math.max(e.x, t.x),
                                y: Math.max(e.y, t.y)
                            };
                        });
                        return {
                            width: n.x + 2 * t.width,
                            height: n.y + 2 * t.height
                        };
                    }(s, a), v = function(e, t, n) {
                        var r = function(t) {
                            return Math.min(e[0][t] - n.width, e[3][t] - n.height);
                        };
                        return {
                            x: t.position.x - r("x") - n.width,
                            y: t.position.y - r("y") - n.height
                        };
                    }(s, f, a);
                    return {
                        pathCommands: h,
                        size: p,
                        offset: v,
                        heads: d
                    };
                };
            },
            312: (e, t)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.DIRECTION = t.HEAD_DEFAULT_SIZE = void 0, t.HEAD_DEFAULT_SIZE = 10, t.DIRECTION = {
                    TOP_LEFT: "top-left",
                    TOP: "top",
                    TOP_RIGHT: "top-right",
                    RIGHT: "right",
                    BOTTOM_LEFT: "bottom-left",
                    BOTTOM: "bottom",
                    BOTTOM_RIGHT: "bottom-right",
                    LEFT: "left"
                };
            },
            240: function(e, t, n) {
                var r = this && this.__assign || function() {
                    return r = Object.assign || function(e) {
                        for(var t, n = 1, r = arguments.length; n < r; n++)for(var o in t = arguments[n])Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
                        return e;
                    }, r.apply(this, arguments);
                };
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.produceContainer = void 0;
                var o = n(134), i = function(e, t, n) {
                    return o.pointSubtraction(r(r({}, e), {
                        x: e.x - t.x,
                        y: e.y - t.y
                    }), {
                        x: 2 * -n.width,
                        y: 2 * -n.height
                    });
                };
                t.produceContainer = function(e, t, n) {
                    var r = {
                        x: Math.min(e.x, t.x),
                        y: Math.min(e.y, t.y)
                    }, o = i(e, r, n), u = i(t, r, n), _ = function(e, t) {
                        return {
                            width: Math.max(e.x, t.x),
                            height: Math.max(e.y, t.y)
                        };
                    }(o, u);
                    return {
                        position: r,
                        relativeFrom: o,
                        relativeTo: u,
                        size: _
                    };
                };
            },
            382: function(e, t, n) {
                var r = this && this.__assign || function() {
                    return r = Object.assign || function(e) {
                        for(var t, n = 1, r = arguments.length; n < r; n++)for(var o in t = arguments[n])Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
                        return e;
                    }, r.apply(this, arguments);
                };
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.headTransformCSS = t.assignPathToHeads = t.calculateHeadsPadding = t.prepareHeads = t.prepareHeadNode = void 0;
                var o = n(740), i = function(e) {
                    return Math.round(1e3 * e) / 1e3;
                }, u = function(e) {
                    if ("string" == typeof e) {
                        var t = e;
                        return o.default[t];
                    }
                    if ("object" == typeof e) {
                        if ("function" == typeof e.func) return e.func;
                        if ("string" == typeof e.func) return u(e.func);
                    }
                    if ("function" == typeof e) return e;
                    throw new Error("head type is invalid");
                };
                t.prepareHeadNode = function(e) {
                    var t = u(e)(e);
                    if (!t || !t.width || !t.height) throw new Error("head function should return { node, width, height }");
                    return "object" == typeof e && Object.assign(t, e), t.distance || (t.distance = 1), t;
                }, t.prepareHeads = function(e) {
                    return (Array.isArray(e) ? e : [
                        e
                    ]).map(t.prepareHeadNode);
                }, t.calculateHeadsPadding = function(e) {
                    return e.reduce(function(e, t) {
                        var n = {
                            width: e.width,
                            height: e.height
                        };
                        return t.width > n.width && (n.width = t.width), t.height > n.height && (n.height = t.height), n;
                    }, {
                        width: 0,
                        height: 0
                    });
                }, t.assignPathToHeads = function(e, t) {
                    return e.map(function(e, n) {
                        return r(r(r({
                            id: n
                        }, e), function(e, t) {
                            var n = e.distance, r = function(e) {
                                return Math.pow(1 - n, 2) * (t[1][e] - t[0][e]) + 2 * n * (1 - n) * (t[2][e] - t[1][e]) + n * n * (t[3][e] - t[2][e]);
                            }, o = r("x"), u = r("y"), _ = i(-Math.atan2(o, u) + .5 * Math.PI);
                            return {
                                degree: i(_ * (180 / Math.PI)),
                                radius: _
                            };
                        }(e, t)), function(e, t) {
                            var n = e.distance, r = function(e) {
                                return Math.pow(1 - n, 3) * t[0][e] + 3 * n * Math.pow(1 - n, 2) * t[1][e] + 3 * n * n * (1 - n) * t[2][e] + n * n * n * t[3][e];
                            };
                            return {
                                x: r("x"),
                                y: r("y")
                            };
                        }(e, t));
                    });
                }, t.headTransformCSS = function(e) {
                    return "rotate(" + e.degree + ", " + e.x + ", " + e.y + "), translate(" + e.x + ", " + e.y + ")";
                };
            },
            981: function(e, t, n) {
                var r = this && this.__createBinding || (Object.create ? function(e, t, n, r) {
                    void 0 === r && (r = n), Object.defineProperty(e, r, {
                        enumerable: !0,
                        get: function() {
                            return t[n];
                        }
                    });
                } : function(e, t, n, r) {
                    void 0 === r && (r = n), e[r] = t[n];
                }), o = this && this.__exportStar || function(e, t) {
                    for(var n in e)"default" === n || Object.prototype.hasOwnProperty.call(t, n) || r(t, e, n);
                };
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HEAD = void 0, o(n(382), t);
                var i = n(740);
                Object.defineProperty(t, "HEAD", {
                    enumerable: !0,
                    get: function() {
                        return i.default;
                    }
                });
            },
            380: (e, t, n)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var r = n(400), o = n(312);
                t.default = function(e) {
                    var t = e.size, n = void 0 === t ? o.HEAD_DEFAULT_SIZE : t;
                    return {
                        node: r.h("g", {
                            transform: "translate(-" + n + ", 0)"
                        }, r.h("path", {
                            d: "M" + -n + " 0 L0 " + -n + " L" + n + " 0 L0 " + n + " Z"
                        })),
                        width: n,
                        height: n
                    };
                };
            },
            796: (e, t, n)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var r = n(400), o = n(312);
                t.default = function(e) {
                    var t = e.size, n = void 0 === t ? o.HEAD_DEFAULT_SIZE : t;
                    return {
                        node: r.h("g", {
                            transform: "translate(-" + n + ", 0)"
                        }, r.h("circle", {
                            cx: 0,
                            cy: 0,
                            r: n
                        })),
                        width: n,
                        height: n
                    };
                };
            },
            591: (e, t)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e) {
                    var t = e.src, n = e.width, r = e.height;
                    if (!t || !n || !r) throw new Error("image requires src, height, width");
                    var o = document.createElementNS("http://www.w3.org/2000/svg", "image");
                    return o.setAttributeNS(null, "width", String(n)), o.setAttributeNS(null, "height", String(r)), o.setAttributeNS(null, "x", String(-n)), o.setAttributeNS(null, "y", String(-r / 2)), o.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", t), {
                        node: o,
                        width: n,
                        height: r
                    };
                };
            },
            740: (e, t, n)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var r = n(380), o = n(796), i = n(591), u = n(729), _ = n(777), a = n(263), l = n(549), c = n(579), f = {
                    diamond: r.default,
                    DIAMOND: r.default,
                    dot: o.default,
                    DOT: o.default,
                    image: i.default,
                    IMAGE: i.default,
                    none: a.default,
                    NONE: a.default,
                    inv: u.default,
                    INV: u.default,
                    normal: _.default,
                    NORMAL: _.default,
                    thin: l.default,
                    THIN: l.default,
                    vee: c.default,
                    VEE: c.default
                };
                t.default = f;
            },
            729: (e, t, n)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var r = n(400), o = n(312);
                t.default = function(e) {
                    var t = e.size, n = void 0 === t ? o.HEAD_DEFAULT_SIZE : t;
                    return {
                        node: r.h("path", {
                            d: "M" + -n + " 0 L0 " + -n + " L0 " + n + " Z"
                        }),
                        width: n,
                        height: n
                    };
                };
            },
            263: (e, t, n)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var r = n(312);
                t.default = function() {
                    return {
                        node: null,
                        width: r.HEAD_DEFAULT_SIZE,
                        height: r.HEAD_DEFAULT_SIZE
                    };
                };
            },
            777: (e, t, n)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var r = n(400), o = n(312);
                t.default = function(e) {
                    var t = e.size, n = void 0 === t ? o.HEAD_DEFAULT_SIZE : t;
                    return {
                        node: r.h("path", {
                            d: "M" + -n + " " + -n + " L0 0 L" + -n + " " + n + " Z"
                        }),
                        width: n,
                        height: n
                    };
                };
            },
            549: (e, t, n)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var r = n(400), o = n(312);
                t.default = function(e) {
                    var t = e.size, n = void 0 === t ? o.HEAD_DEFAULT_SIZE : t;
                    return {
                        node: r.h("g", null, r.h("line", {
                            x1: -n,
                            y1: -n,
                            x2: 0,
                            y2: 0
                        }), r.h("line", {
                            x1: 0,
                            y1: 0,
                            x2: -n,
                            y2: n
                        })),
                        width: n,
                        height: n
                    };
                };
            },
            579: (e, t, n)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var r = n(400), o = n(312);
                t.default = function(e) {
                    var t = e.size, n = void 0 === t ? o.HEAD_DEFAULT_SIZE : t;
                    return {
                        node: r.h("g", {
                            transform: "translate(-" + n + ", 0)"
                        }, r.h("path", {
                            d: "M" + -n + " " + -n + " L" + n + " 0 L" + -n + " " + n + " L0 0 Z"
                        })),
                        width: n,
                        height: n
                    };
                };
            },
            773: (e, t)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e) {
                    var t = "function" == typeof e ? e() : e;
                    return document.body.contains(t) ? t : null;
                };
            },
            202: (e, t, n)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.assignArrowCreate = void 0;
                var r = n(940);
                t.assignArrowCreate = function(e) {
                    e && (e.arrowCreate = r.default);
                };
            },
            296: (e, t, n)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var r = n(773), o = [
                    "x",
                    "y",
                    "width",
                    "height"
                ], i = {
                    from: null,
                    to: null
                }, u = function(e, t) {
                    var n = t.getBoundingClientRect();
                    return e ? {
                        equal: !o.some(function(t) {
                            return e[t] !== n[t];
                        }),
                        rect: n
                    } : {
                        equal: !1,
                        rect: n
                    };
                };
                t.default = function(e, t, n) {
                    var o, _ = n.updateDelay, a = void 0 === _ ? 0 : _, l = n.update, c = i, f = function() {
                        var n = r.default(e.node), o = r.default(t.node);
                        if (n && o) {
                            var _ = function(e, t, n) {
                                var r = u(e.from, t), o = u(e.to, n);
                                return r.equal && o.equal ? null : {
                                    from: r.rect,
                                    to: o.rect
                                };
                            }(c, n, o);
                            _ && (c !== i && l(), c = _);
                        }
                    };
                    if (a) {
                        var s = setInterval(f, a);
                        return {
                            clear: function() {
                                return clearInterval(s);
                            }
                        };
                    }
                    var d = function() {
                        f(), o = requestAnimationFrame(d);
                    };
                    return o = requestAnimationFrame(d), {
                        clear: function() {
                            return cancelAnimationFrame(o);
                        }
                    };
                };
            },
            945: (e, t, n)=>{
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.pathListBezier = t.pathReducer = t.convertPathToSVG = void 0;
                var r = n(134);
                t.convertPathToSVG = function(e) {
                    var t = [
                        "M"
                    ];
                    return t.push(r.pointToArray(e[0])), t.push("C"), t.push(r.pointToArray(e[1])), t.push(","), t.push(r.pointToArray(e[2])), t.push(","), t.push(r.pointToArray(e[3])), t.flat().join(" ").replace(/ ,/g, ",");
                }, t.pathReducer = function(e, t) {
                    return e.reduce(function(e, n) {
                        return t(e, n);
                    });
                }, t.pathListBezier = function(e, n) {
                    var o = [];
                    return o.push(e.relativeFrom), o.push(r.pointBezier(e.relativeFrom, e.size)), o.push(r.pointBezier(e.relativeTo, e.size)), o.push(e.relativeTo), function(e, n) {
                        var r = t.pathReducer(e, function(e, t) {
                            return {
                                x: Math.min(e.x, t.x),
                                y: Math.min(e.y, t.y)
                            };
                        });
                        return e.map(function(e) {
                            return {
                                x: e.x - r.x + n.width,
                                y: e.y - r.y + n.height
                            };
                        });
                    }(o, n);
                };
            },
            134: function(e, t) {
                var n = this && this.__assign || function() {
                    return n = Object.assign || function(e) {
                        for(var t, n = 1, r = arguments.length; n < r; n++)for(var o in t = arguments[n])Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
                        return e;
                    }, n.apply(this, arguments);
                };
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.pointSubtraction = t.pointBezier = t.pointToArray = void 0, t.pointToArray = function(e) {
                    return [
                        e.x,
                        e.y
                    ];
                }, t.pointBezier = function(e, t) {
                    return {
                        x: e.x + t.width * e.translation[0],
                        y: e.y + t.height * e.translation[1]
                    };
                }, t.pointSubtraction = function(e, t) {
                    return n(n({}, e), {
                        x: e.x - t.x,
                        y: e.y - t.y
                    });
                };
            }
        }, t = {};
        function n(r) {
            var o = t[r];
            if (void 0 !== o) return o.exports;
            var i = t[r] = {
                exports: {}
            };
            return e[r].call(i.exports, i, i.exports, n), i.exports;
        }
        n.d = (e, t)=>{
            for(var r in t)n.o(t, r) && !n.o(e, r) && Object.defineProperty(e, r, {
                enumerable: !0,
                get: t[r]
            });
        }, n.o = (e, t)=>Object.prototype.hasOwnProperty.call(e, t), n.r = (e)=>{
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                value: "Module"
            }), Object.defineProperty(e, "__esModule", {
                value: !0
            });
        };
        var r = {};
        return (()=>{
            var e = r;
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.observer = e.HEAD = e.headTransformCSS = e.arrowVector = e.castToAnchor = e.DIRECTION = e.arrowCreate = void 0;
            var t = n(202), o = n(940);
            e.arrowCreate = o.default, t.assignArrowCreate(window), e.default = o.default;
            var i = n(312);
            Object.defineProperty(e, "DIRECTION", {
                enumerable: !0,
                get: function() {
                    return i.DIRECTION;
                }
            });
            var u = n(515);
            Object.defineProperty(e, "castToAnchor", {
                enumerable: !0,
                get: function() {
                    return u.castToAnchor;
                }
            });
            var _ = n(778);
            Object.defineProperty(e, "arrowVector", {
                enumerable: !0,
                get: function() {
                    return _.default;
                }
            });
            var a = n(981);
            Object.defineProperty(e, "headTransformCSS", {
                enumerable: !0,
                get: function() {
                    return a.headTransformCSS;
                }
            }), Object.defineProperty(e, "HEAD", {
                enumerable: !0,
                get: function() {
                    return a.HEAD;
                }
            });
            var l = n(296);
            Object.defineProperty(e, "observer", {
                enumerable: !0,
                get: function() {
                    return l.default;
                }
            });
        })(), r;
    })());
}}),
"[project]/node_modules/mitt/dist/mitt.mjs [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
function __TURBOPACK__default__export__(n) {
    return {
        all: n = n || new Map,
        on: function(t, e) {
            var i = n.get(t);
            i ? i.push(e) : n.set(t, [
                e
            ]);
        },
        off: function(t, e) {
            var i = n.get(t);
            i && (e ? i.splice(i.indexOf(e) >>> 0, 1) : n.set(t, []));
        },
        emit: function(t, e) {
            var i = n.get(t);
            i && i.slice().map(function(n) {
                n(e);
            }), (i = n.get("*")) && i.slice().map(function(n) {
                n(t, e);
            });
        }
    };
} //# sourceMappingURL=mitt.mjs.map
}}),
"[project]/node_modules/nuqs/dist/chunk-S2OHQSN3.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "FLUSH_RATE_LIMIT_MS": (()=>FLUSH_RATE_LIMIT_MS),
    "enqueueQueryStringUpdate": (()=>enqueueQueryStringUpdate),
    "getQueuedValue": (()=>getQueuedValue),
    "resetQueue": (()=>resetQueue),
    "safeParse": (()=>safeParse),
    "scheduleFlushToURL": (()=>scheduleFlushToURL)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nuqs$2f$dist$2f$chunk$2d$3RCMAOX7$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/nuqs/dist/chunk-3RCMAOX7.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nuqs$2f$dist$2f$chunk$2d$DASHEO2X$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/nuqs/dist/chunk-DASHEO2X.js [client] (ecmascript)");
;
;
// src/utils.ts
function safeParse(parser, value, key) {
    try {
        return parser(value);
    } catch (error2) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nuqs$2f$dist$2f$chunk$2d$3RCMAOX7$2e$js__$5b$client$5d$__$28$ecmascript$29$__["warn"])("[nuqs] Error while parsing value `%s`: %O" + (key ? " (for key `%s`)" : ""), value, error2, key);
        return null;
    }
}
function getDefaultThrottle() {
    if (typeof window === "undefined") return 50;
    const isSafari = Boolean(window.GestureEvent);
    if (!isSafari) {
        return 50;
    }
    try {
        const match = navigator.userAgent?.match(/version\/([\d\.]+) safari/i);
        return parseFloat(match[1]) >= 17 ? 120 : 320;
    } catch  {
        return 320;
    }
}
// src/update-queue.ts
var FLUSH_RATE_LIMIT_MS = getDefaultThrottle();
var updateQueue = /* @__PURE__ */ new Map();
var queueOptions = {
    history: "replace",
    scroll: false,
    shallow: true,
    throttleMs: FLUSH_RATE_LIMIT_MS
};
var transitionsQueue = /* @__PURE__ */ new Set();
var lastFlushTimestamp = 0;
var flushPromiseCache = null;
function getQueuedValue(key) {
    return updateQueue.get(key);
}
function resetQueue() {
    updateQueue.clear();
    transitionsQueue.clear();
    queueOptions.history = "replace";
    queueOptions.scroll = false;
    queueOptions.shallow = true;
    queueOptions.throttleMs = FLUSH_RATE_LIMIT_MS;
}
function enqueueQueryStringUpdate(key, value, serialize, options) {
    const serializedOrNull = value === null ? null : serialize(value);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nuqs$2f$dist$2f$chunk$2d$3RCMAOX7$2e$js__$5b$client$5d$__$28$ecmascript$29$__["debug"])("[nuqs queue] Enqueueing %s=%s %O", key, serializedOrNull, options);
    updateQueue.set(key, serializedOrNull);
    if (options.history === "push") {
        queueOptions.history = "push";
    }
    if (options.scroll) {
        queueOptions.scroll = true;
    }
    if (options.shallow === false) {
        queueOptions.shallow = false;
    }
    if (options.startTransition) {
        transitionsQueue.add(options.startTransition);
    }
    queueOptions.throttleMs = Math.max(options.throttleMs ?? FLUSH_RATE_LIMIT_MS, Number.isFinite(queueOptions.throttleMs) ? queueOptions.throttleMs : 0);
    return serializedOrNull;
}
function getSearchParamsSnapshotFromLocation() {
    return new URLSearchParams(location.search);
}
function scheduleFlushToURL({ getSearchParamsSnapshot = getSearchParamsSnapshotFromLocation, updateUrl, rateLimitFactor = 1 }) {
    if (flushPromiseCache === null) {
        flushPromiseCache = new Promise((resolve, reject)=>{
            if (!Number.isFinite(queueOptions.throttleMs)) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nuqs$2f$dist$2f$chunk$2d$3RCMAOX7$2e$js__$5b$client$5d$__$28$ecmascript$29$__["debug"])("[nuqs queue] Skipping flush due to throttleMs=Infinity");
                resolve(getSearchParamsSnapshot());
                setTimeout(()=>{
                    flushPromiseCache = null;
                }, 0);
                return;
            }
            function flushNow() {
                lastFlushTimestamp = performance.now();
                const [search, error2] = flushUpdateQueue({
                    updateUrl,
                    getSearchParamsSnapshot
                });
                if (error2 === null) {
                    resolve(search);
                } else {
                    reject(search);
                }
                flushPromiseCache = null;
            }
            function runOnNextTick() {
                const now = performance.now();
                const timeSinceLastFlush = now - lastFlushTimestamp;
                const throttleMs = queueOptions.throttleMs;
                const flushInMs = rateLimitFactor * Math.max(0, Math.min(throttleMs, throttleMs - timeSinceLastFlush));
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nuqs$2f$dist$2f$chunk$2d$3RCMAOX7$2e$js__$5b$client$5d$__$28$ecmascript$29$__["debug"])("[nuqs queue] Scheduling flush in %f ms. Throttled at %f ms", flushInMs, throttleMs);
                if (flushInMs === 0) {
                    flushNow();
                } else {
                    setTimeout(flushNow, flushInMs);
                }
            }
            setTimeout(runOnNextTick, 0);
        });
    }
    return flushPromiseCache;
}
function flushUpdateQueue({ updateUrl, getSearchParamsSnapshot }) {
    const search = getSearchParamsSnapshot();
    if (updateQueue.size === 0) {
        return [
            search,
            null
        ];
    }
    const items = Array.from(updateQueue.entries());
    const options = {
        ...queueOptions
    };
    const transitions = Array.from(transitionsQueue);
    resetQueue();
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nuqs$2f$dist$2f$chunk$2d$3RCMAOX7$2e$js__$5b$client$5d$__$28$ecmascript$29$__["debug"])("[nuqs queue] Flushing queue %O with options %O", items, options);
    for (const [key, value] of items){
        if (value === null) {
            search.delete(key);
        } else {
            search.set(key, value);
        }
    }
    try {
        compose(transitions, ()=>{
            updateUrl(search, {
                history: options.history,
                scroll: options.scroll,
                shallow: options.shallow
            });
        });
        return [
            search,
            null
        ];
    } catch (err) {
        console.error((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nuqs$2f$dist$2f$chunk$2d$DASHEO2X$2e$js__$5b$client$5d$__$28$ecmascript$29$__["error"])(429), items.map(([key])=>key).join(), err);
        return [
            search,
            err
        ];
    }
}
function compose(fns, final) {
    const recursiveCompose = (index)=>{
        if (index === fns.length) {
            return final();
        }
        const fn = fns[index];
        if (!fn) {
            throw new Error("Invalid transition function");
        }
        fn(()=>recursiveCompose(index + 1));
    };
    recursiveCompose(0);
}
;
}}),
"[project]/node_modules/nuqs/dist/index.js [client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "createLoader": (()=>createLoader),
    "createParser": (()=>createParser),
    "createSerializer": (()=>createSerializer),
    "parseAsArrayOf": (()=>parseAsArrayOf),
    "parseAsBoolean": (()=>parseAsBoolean),
    "parseAsFloat": (()=>parseAsFloat),
    "parseAsHex": (()=>parseAsHex),
    "parseAsInteger": (()=>parseAsInteger),
    "parseAsIsoDate": (()=>parseAsIsoDate),
    "parseAsIsoDateTime": (()=>parseAsIsoDateTime),
    "parseAsJson": (()=>parseAsJson),
    "parseAsNumberLiteral": (()=>parseAsNumberLiteral),
    "parseAsString": (()=>parseAsString),
    "parseAsStringEnum": (()=>parseAsStringEnum),
    "parseAsStringLiteral": (()=>parseAsStringLiteral),
    "parseAsTimestamp": (()=>parseAsTimestamp),
    "useQueryState": (()=>useQueryState),
    "useQueryStates": (()=>useQueryStates)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/react/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mitt$2f$dist$2f$mitt$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/mitt/dist/mitt.mjs [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nuqs$2f$dist$2f$chunk$2d$S2OHQSN3$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/nuqs/dist/chunk-S2OHQSN3.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nuqs$2f$dist$2f$chunk$2d$DASHEO2X$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/nuqs/dist/chunk-DASHEO2X.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nuqs$2f$dist$2f$chunk$2d$3RCMAOX7$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/nuqs/dist/chunk-3RCMAOX7.js [client] (ecmascript)");
'use client';
;
;
;
;
;
// src/loader.ts
function createLoader(parsers, { urlKeys = {} } = {}) {
    function loadSearchParams(input) {
        if (input instanceof Promise) {
            return input.then((i)=>loadSearchParams(i));
        }
        const searchParams = extractSearchParams(input);
        const result = {};
        for (const [key, parser] of Object.entries(parsers)){
            const urlKey = urlKeys[key] ?? key;
            const value = searchParams.get(urlKey);
            result[key] = parser.parseServerSide(value ?? void 0);
        }
        return result;
    }
    return loadSearchParams;
}
function extractSearchParams(input) {
    try {
        if (input instanceof Request) {
            if (input.url) {
                return new URL(input.url).searchParams;
            } else {
                return new URLSearchParams();
            }
        }
        if (input instanceof URL) {
            return input.searchParams;
        }
        if (input instanceof URLSearchParams) {
            return input;
        }
        if (typeof input === "object") {
            const entries = Object.entries(input);
            const searchParams = new URLSearchParams();
            for (const [key, value] of entries){
                if (Array.isArray(value)) {
                    for (const v of value){
                        searchParams.append(key, v);
                    }
                } else if (value !== void 0) {
                    searchParams.set(key, value);
                }
            }
            return searchParams;
        }
        if (typeof input === "string") {
            if ("canParse" in URL && URL.canParse(input)) {
                return new URL(input).searchParams;
            }
            return new URLSearchParams(input);
        }
    } catch (e) {
        return new URLSearchParams();
    }
    return new URLSearchParams();
}
// src/parsers.ts
function createParser(parser) {
    function parseServerSideNullable(value) {
        if (typeof value === "undefined") {
            return null;
        }
        let str = "";
        if (Array.isArray(value)) {
            if (value[0] === void 0) {
                return null;
            }
            str = value[0];
        }
        if (typeof value === "string") {
            str = value;
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nuqs$2f$dist$2f$chunk$2d$S2OHQSN3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["safeParse"])(parser.parse, str);
    }
    return {
        eq: (a, b)=>a === b,
        ...parser,
        parseServerSide: parseServerSideNullable,
        withDefault (defaultValue) {
            return {
                ...this,
                defaultValue,
                parseServerSide (value) {
                    return parseServerSideNullable(value) ?? defaultValue;
                }
            };
        },
        withOptions (options) {
            return {
                ...this,
                ...options
            };
        }
    };
}
var parseAsString = createParser({
    parse: (v)=>v,
    serialize: (v)=>`${v}`
});
var parseAsInteger = createParser({
    parse: (v)=>{
        const int = parseInt(v);
        if (Number.isNaN(int)) {
            return null;
        }
        return int;
    },
    serialize: (v)=>Math.round(v).toFixed()
});
var parseAsHex = createParser({
    parse: (v)=>{
        const int = parseInt(v, 16);
        if (Number.isNaN(int)) {
            return null;
        }
        return int;
    },
    serialize: (v)=>{
        const hex = Math.round(v).toString(16);
        return hex.padStart(hex.length + hex.length % 2, "0");
    }
});
var parseAsFloat = createParser({
    parse: (v)=>{
        const float = parseFloat(v);
        if (Number.isNaN(float)) {
            return null;
        }
        return float;
    },
    serialize: (v)=>v.toString()
});
var parseAsBoolean = createParser({
    parse: (v)=>v === "true",
    serialize: (v)=>v ? "true" : "false"
});
var parseAsTimestamp = createParser({
    parse: (v)=>{
        const ms = parseInt(v);
        if (Number.isNaN(ms)) {
            return null;
        }
        return new Date(ms);
    },
    serialize: (v)=>v.valueOf().toString()
});
var parseAsIsoDateTime = createParser({
    parse: (v)=>{
        const date = new Date(v);
        if (Number.isNaN(date.valueOf())) {
            return null;
        }
        return date;
    },
    serialize: (v)=>v.toISOString()
});
var parseAsIsoDate = createParser({
    parse: (v)=>{
        const date = new Date(v.slice(0, 10));
        if (Number.isNaN(date.valueOf())) {
            return null;
        }
        return date;
    },
    serialize: (v)=>v.toISOString().slice(0, 10)
});
function parseAsStringEnum(validValues) {
    return createParser({
        parse: (query)=>{
            const asEnum = query;
            if (validValues.includes(asEnum)) {
                return asEnum;
            }
            return null;
        },
        serialize: (value)=>value.toString()
    });
}
function parseAsStringLiteral(validValues) {
    return createParser({
        parse: (query)=>{
            const asConst = query;
            if (validValues.includes(asConst)) {
                return asConst;
            }
            return null;
        },
        serialize: (value)=>value.toString()
    });
}
function parseAsNumberLiteral(validValues) {
    return createParser({
        parse: (query)=>{
            const asConst = parseFloat(query);
            if (validValues.includes(asConst)) {
                return asConst;
            }
            return null;
        },
        serialize: (value)=>value.toString()
    });
}
function parseAsJson(runtimeParser) {
    return createParser({
        parse: (query)=>{
            try {
                const obj = JSON.parse(query);
                return runtimeParser(obj);
            } catch  {
                return null;
            }
        },
        serialize: (value)=>JSON.stringify(value),
        eq (a, b) {
            return a === b || JSON.stringify(a) === JSON.stringify(b);
        }
    });
}
function parseAsArrayOf(itemParser, separator = ",") {
    const itemEq = itemParser.eq ?? ((a, b)=>a === b);
    const encodedSeparator = encodeURIComponent(separator);
    return createParser({
        parse: (query)=>{
            if (query === "") {
                return [];
            }
            return query.split(separator).map((item, index)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nuqs$2f$dist$2f$chunk$2d$S2OHQSN3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["safeParse"])(itemParser.parse, item.replaceAll(encodedSeparator, separator), `[${index}]`)).filter((value)=>value !== null && value !== void 0);
        },
        serialize: (values)=>values.map((value)=>{
                const str = itemParser.serialize ? itemParser.serialize(value) : String(value);
                return str.replaceAll(separator, encodedSeparator);
            }).join(separator),
        eq (a, b) {
            if (a === b) {
                return true;
            }
            if (a.length !== b.length) {
                return false;
            }
            return a.every((value, index)=>itemEq(value, b[index]));
        }
    });
}
// src/serializer.ts
function createSerializer(parsers, { clearOnDefault = true, urlKeys = {} } = {}) {
    function serialize(arg1BaseOrValues, arg2values = {}) {
        const [base, search] = isBase(arg1BaseOrValues) ? splitBase(arg1BaseOrValues) : [
            "",
            new URLSearchParams()
        ];
        const values = isBase(arg1BaseOrValues) ? arg2values : arg1BaseOrValues;
        if (values === null) {
            for(const key in parsers){
                const urlKey = urlKeys[key] ?? key;
                search.delete(urlKey);
            }
            return base + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nuqs$2f$dist$2f$chunk$2d$DASHEO2X$2e$js__$5b$client$5d$__$28$ecmascript$29$__["renderQueryString"])(search);
        }
        for(const key in parsers){
            const parser = parsers[key];
            const value = values[key];
            if (!parser || value === void 0) {
                continue;
            }
            const urlKey = urlKeys[key] ?? key;
            const isMatchingDefault = parser.defaultValue !== void 0 && (parser.eq ?? ((a, b)=>a === b))(value, parser.defaultValue);
            if (value === null || (parser.clearOnDefault ?? clearOnDefault ?? true) && isMatchingDefault) {
                search.delete(urlKey);
            } else {
                search.set(urlKey, parser.serialize(value));
            }
        }
        return base + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nuqs$2f$dist$2f$chunk$2d$DASHEO2X$2e$js__$5b$client$5d$__$28$ecmascript$29$__["renderQueryString"])(search);
    }
    return serialize;
}
function isBase(base) {
    return typeof base === "string" || base instanceof URLSearchParams || base instanceof URL;
}
function splitBase(base) {
    if (typeof base === "string") {
        const [path = "", ...search] = base.split("?");
        return [
            path,
            new URLSearchParams(search.join("?"))
        ];
    } else if (base instanceof URLSearchParams) {
        return [
            "",
            new URLSearchParams(base)
        ];
    } else {
        return [
            base.origin + base.pathname,
            new URLSearchParams(base.searchParams)
        ];
    }
}
var emitter = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mitt$2f$dist$2f$mitt$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["default"])();
// src/useQueryState.ts
function useQueryState(key, { history = "replace", shallow = true, scroll = false, throttleMs = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nuqs$2f$dist$2f$chunk$2d$S2OHQSN3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["FLUSH_RATE_LIMIT_MS"], parse = (x)=>x, serialize = String, eq = (a, b)=>a === b, defaultValue = void 0, clearOnDefault = true, startTransition } = {
    history: "replace",
    scroll: false,
    shallow: true,
    throttleMs: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nuqs$2f$dist$2f$chunk$2d$S2OHQSN3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["FLUSH_RATE_LIMIT_MS"],
    parse: (x)=>x,
    serialize: String,
    eq: (a, b)=>a === b,
    clearOnDefault: true,
    defaultValue: void 0
}) {
    const adapter = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nuqs$2f$dist$2f$chunk$2d$DASHEO2X$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useAdapter"])();
    const initialSearchParams = adapter.searchParams;
    const queryRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useRef"])(initialSearchParams?.get(key) ?? null);
    const [internalState, setInternalState] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useState"])({
        "useQueryState.useState": ()=>{
            const queuedQuery = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nuqs$2f$dist$2f$chunk$2d$S2OHQSN3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getQueuedValue"])(key);
            const query = queuedQuery === void 0 ? initialSearchParams?.get(key) ?? null : queuedQuery;
            return query === null ? null : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nuqs$2f$dist$2f$chunk$2d$S2OHQSN3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["safeParse"])(parse, query, key);
        }
    }["useQueryState.useState"]);
    const stateRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useRef"])(internalState);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nuqs$2f$dist$2f$chunk$2d$3RCMAOX7$2e$js__$5b$client$5d$__$28$ecmascript$29$__["debug"])("[nuqs `%s`] render - state: %O, iSP: %s", key, internalState, initialSearchParams?.get(key) ?? null);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useQueryState.useEffect": ()=>{
            const query = initialSearchParams?.get(key) ?? null;
            if (query === queryRef.current) {
                return;
            }
            const state = query === null ? null : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nuqs$2f$dist$2f$chunk$2d$S2OHQSN3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["safeParse"])(parse, query, key);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nuqs$2f$dist$2f$chunk$2d$3RCMAOX7$2e$js__$5b$client$5d$__$28$ecmascript$29$__["debug"])("[nuqs `%s`] syncFromUseSearchParams %O", key, state);
            stateRef.current = state;
            queryRef.current = query;
            setInternalState(state);
        }
    }["useQueryState.useEffect"], [
        initialSearchParams?.get(key),
        key
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useQueryState.useEffect": ()=>{
            function updateInternalState({ state, query }) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nuqs$2f$dist$2f$chunk$2d$3RCMAOX7$2e$js__$5b$client$5d$__$28$ecmascript$29$__["debug"])("[nuqs `%s`] updateInternalState %O", key, state);
                stateRef.current = state;
                queryRef.current = query;
                setInternalState(state);
            }
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nuqs$2f$dist$2f$chunk$2d$3RCMAOX7$2e$js__$5b$client$5d$__$28$ecmascript$29$__["debug"])("[nuqs `%s`] subscribing to sync", key);
            emitter.on(key, updateInternalState);
            return ({
                "useQueryState.useEffect": ()=>{
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nuqs$2f$dist$2f$chunk$2d$3RCMAOX7$2e$js__$5b$client$5d$__$28$ecmascript$29$__["debug"])("[nuqs `%s`] unsubscribing from sync", key);
                    emitter.off(key, updateInternalState);
                }
            })["useQueryState.useEffect"];
        }
    }["useQueryState.useEffect"], [
        key
    ]);
    const update = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useQueryState.useCallback[update]": (stateUpdater, options = {})=>{
            let newValue = isUpdaterFunction(stateUpdater) ? stateUpdater(stateRef.current ?? defaultValue ?? null) : stateUpdater;
            if ((options.clearOnDefault ?? clearOnDefault) && newValue !== null && defaultValue !== void 0 && eq(newValue, defaultValue)) {
                newValue = null;
            }
            const query = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nuqs$2f$dist$2f$chunk$2d$S2OHQSN3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["enqueueQueryStringUpdate"])(key, newValue, serialize, {
                // Call-level options take precedence over hook declaration options.
                history: options.history ?? history,
                shallow: options.shallow ?? shallow,
                scroll: options.scroll ?? scroll,
                throttleMs: options.throttleMs ?? throttleMs,
                startTransition: options.startTransition ?? startTransition
            });
            emitter.emit(key, {
                state: newValue,
                query
            });
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nuqs$2f$dist$2f$chunk$2d$S2OHQSN3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["scheduleFlushToURL"])(adapter);
        }
    }["useQueryState.useCallback[update]"], [
        key,
        history,
        shallow,
        scroll,
        throttleMs,
        startTransition,
        adapter
    ]);
    return [
        internalState ?? defaultValue ?? null,
        update
    ];
}
function isUpdaterFunction(stateUpdater) {
    return typeof stateUpdater === "function";
}
var defaultUrlKeys = {};
function useQueryStates(keyMap, { history = "replace", scroll = false, shallow = true, throttleMs = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nuqs$2f$dist$2f$chunk$2d$S2OHQSN3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["FLUSH_RATE_LIMIT_MS"], clearOnDefault = true, startTransition, urlKeys = defaultUrlKeys } = {}) {
    const stateKeys = Object.keys(keyMap).join(",");
    const resolvedUrlKeys = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "useQueryStates.useMemo[resolvedUrlKeys]": ()=>Object.fromEntries(Object.keys(keyMap).map({
                "useQueryStates.useMemo[resolvedUrlKeys]": (key)=>[
                        key,
                        urlKeys[key] ?? key
                    ]
            }["useQueryStates.useMemo[resolvedUrlKeys]"]))
    }["useQueryStates.useMemo[resolvedUrlKeys]"], [
        stateKeys,
        urlKeys
    ]);
    const adapter = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nuqs$2f$dist$2f$chunk$2d$DASHEO2X$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useAdapter"])();
    const initialSearchParams = adapter.searchParams;
    const queryRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useRef"])({});
    if (Object.keys(queryRef.current).length !== Object.keys(keyMap).length) {
        queryRef.current = Object.fromEntries(initialSearchParams?.entries() ?? []);
    }
    const defaultValues = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "useQueryStates.useMemo[defaultValues]": ()=>Object.fromEntries(Object.keys(keyMap).map({
                "useQueryStates.useMemo[defaultValues]": (key)=>[
                        key,
                        keyMap[key].defaultValue ?? null
                    ]
            }["useQueryStates.useMemo[defaultValues]"]))
    }["useQueryStates.useMemo[defaultValues]"], [
        Object.values(keyMap).map({
            "useQueryStates.useMemo[defaultValues]": ({ defaultValue })=>defaultValue
        }["useQueryStates.useMemo[defaultValues]"]).join(",")
    ]);
    const [internalState, setInternalState] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useState"])({
        "useQueryStates.useState": ()=>{
            const source = initialSearchParams ?? new URLSearchParams();
            return parseMap(keyMap, urlKeys, source);
        }
    }["useQueryStates.useState"]);
    const stateRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useRef"])(internalState);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nuqs$2f$dist$2f$chunk$2d$3RCMAOX7$2e$js__$5b$client$5d$__$28$ecmascript$29$__["debug"])("[nuq+ `%s`] render - state: %O, iSP: %s", stateKeys, internalState, initialSearchParams);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useQueryStates.useEffect": ()=>{
            const state = parseMap(keyMap, urlKeys, initialSearchParams, queryRef.current, stateRef.current);
            stateRef.current = state;
            setInternalState(state);
        }
    }["useQueryStates.useEffect"], [
        Object.values(resolvedUrlKeys).map({
            "useQueryStates.useEffect": (key)=>initialSearchParams?.get(key)
        }["useQueryStates.useEffect"]).join("&")
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useQueryStates.useEffect": ()=>{
            function updateInternalState(state) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nuqs$2f$dist$2f$chunk$2d$3RCMAOX7$2e$js__$5b$client$5d$__$28$ecmascript$29$__["debug"])("[nuq+ `%s`] updateInternalState %O", stateKeys, state);
                stateRef.current = state;
                setInternalState(state);
            }
            const handlers = Object.keys(keyMap).reduce({
                "useQueryStates.useEffect.handlers": (handlers2, stateKey)=>{
                    handlers2[stateKey] = ({
                        "useQueryStates.useEffect.handlers": ({ state, query })=>{
                            const { defaultValue } = keyMap[stateKey];
                            const urlKey = resolvedUrlKeys[stateKey];
                            stateRef.current = {
                                ...stateRef.current,
                                [stateKey]: state ?? defaultValue ?? null
                            };
                            queryRef.current[urlKey] = query;
                            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nuqs$2f$dist$2f$chunk$2d$3RCMAOX7$2e$js__$5b$client$5d$__$28$ecmascript$29$__["debug"])("[nuq+ `%s`] Cross-hook key sync %s: %O (default: %O). Resolved: %O", stateKeys, urlKey, state, defaultValue, stateRef.current);
                            updateInternalState(stateRef.current);
                        }
                    })["useQueryStates.useEffect.handlers"];
                    return handlers2;
                }
            }["useQueryStates.useEffect.handlers"], {});
            for (const stateKey of Object.keys(keyMap)){
                const urlKey = resolvedUrlKeys[stateKey];
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nuqs$2f$dist$2f$chunk$2d$3RCMAOX7$2e$js__$5b$client$5d$__$28$ecmascript$29$__["debug"])("[nuq+ `%s`] Subscribing to sync for `%s`", stateKeys, urlKey);
                emitter.on(urlKey, handlers[stateKey]);
            }
            return ({
                "useQueryStates.useEffect": ()=>{
                    for (const stateKey of Object.keys(keyMap)){
                        const urlKey = resolvedUrlKeys[stateKey];
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nuqs$2f$dist$2f$chunk$2d$3RCMAOX7$2e$js__$5b$client$5d$__$28$ecmascript$29$__["debug"])("[nuq+ `%s`] Unsubscribing to sync for `%s`", stateKeys, urlKey);
                        emitter.off(urlKey, handlers[stateKey]);
                    }
                }
            })["useQueryStates.useEffect"];
        }
    }["useQueryStates.useEffect"], [
        keyMap,
        resolvedUrlKeys
    ]);
    const update = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useQueryStates.useCallback[update]": (stateUpdater, callOptions = {})=>{
            const newState = typeof stateUpdater === "function" ? stateUpdater(applyDefaultValues(stateRef.current, defaultValues)) : stateUpdater === null ? Object.fromEntries(Object.keys(keyMap).map({
                "useQueryStates.useCallback[update]": (key)=>[
                        key,
                        null
                    ]
            }["useQueryStates.useCallback[update]"])) : stateUpdater;
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nuqs$2f$dist$2f$chunk$2d$3RCMAOX7$2e$js__$5b$client$5d$__$28$ecmascript$29$__["debug"])("[nuq+ `%s`] setState: %O", stateKeys, newState);
            for (let [stateKey, value] of Object.entries(newState)){
                const parser = keyMap[stateKey];
                const urlKey = resolvedUrlKeys[stateKey];
                if (!parser) {
                    continue;
                }
                if ((callOptions.clearOnDefault ?? parser.clearOnDefault ?? clearOnDefault) && value !== null && parser.defaultValue !== void 0 && (parser.eq ?? ({
                    "useQueryStates.useCallback[update]": (a, b)=>a === b
                })["useQueryStates.useCallback[update]"])(value, parser.defaultValue)) {
                    value = null;
                }
                const query = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nuqs$2f$dist$2f$chunk$2d$S2OHQSN3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["enqueueQueryStringUpdate"])(urlKey, value, parser.serialize ?? String, {
                    // Call-level options take precedence over individual parser options
                    // which take precedence over global options
                    history: callOptions.history ?? parser.history ?? history,
                    shallow: callOptions.shallow ?? parser.shallow ?? shallow,
                    scroll: callOptions.scroll ?? parser.scroll ?? scroll,
                    throttleMs: callOptions.throttleMs ?? parser.throttleMs ?? throttleMs,
                    startTransition: callOptions.startTransition ?? parser.startTransition ?? startTransition
                });
                emitter.emit(urlKey, {
                    state: value,
                    query
                });
            }
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nuqs$2f$dist$2f$chunk$2d$S2OHQSN3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["scheduleFlushToURL"])(adapter);
        }
    }["useQueryStates.useCallback[update]"], [
        keyMap,
        history,
        shallow,
        scroll,
        throttleMs,
        startTransition,
        resolvedUrlKeys,
        adapter,
        defaultValues
    ]);
    const outputState = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "useQueryStates.useMemo[outputState]": ()=>applyDefaultValues(internalState, defaultValues)
    }["useQueryStates.useMemo[outputState]"], [
        internalState,
        defaultValues
    ]);
    return [
        outputState,
        update
    ];
}
function parseMap(keyMap, urlKeys, searchParams, cachedQuery, cachedState) {
    return Object.keys(keyMap).reduce((out, stateKey)=>{
        const urlKey = urlKeys?.[stateKey] ?? stateKey;
        const { parse } = keyMap[stateKey];
        const queuedQuery = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nuqs$2f$dist$2f$chunk$2d$S2OHQSN3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["getQueuedValue"])(urlKey);
        const query = queuedQuery === void 0 ? searchParams?.get(urlKey) ?? null : queuedQuery;
        if (cachedQuery && cachedState && cachedQuery[urlKey] === query) {
            out[stateKey] = cachedState[stateKey] ?? null;
            return out;
        }
        const value = query === null ? null : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nuqs$2f$dist$2f$chunk$2d$S2OHQSN3$2e$js__$5b$client$5d$__$28$ecmascript$29$__["safeParse"])(parse, query, stateKey);
        out[stateKey] = value ?? null;
        if (cachedQuery) {
            cachedQuery[urlKey] = query;
        }
        return out;
    }, {});
}
function applyDefaultValues(state, defaults) {
    return Object.fromEntries(Object.keys(state).map((key)=>[
            key,
            state[key] ?? defaults[key] ?? null
        ]));
}
;
}}),
}]);

//# sourceMappingURL=node_modules_5e1df6._.js.map